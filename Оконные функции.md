# Функции ранжирования  
<br>

## RANK  
Перед нами задача, составить рейтинг фильмов за декабрь 1990 г. по продолжительности.
<br>

**Было**
``` 
Title                              |Genre      |Duration|
-----------------------------------+-----------+--------+
Man forward.                       |Adventure  |     179|
Phone door.                        |Action     |     178|
Hot recently trip.                 |Comedy     |     178|
Future say bad.                    |Thriller   |     176|
From look.                         |Horror     |     176|
Question myself.                   |Fantasy    |     176|
Hour image special.                |Fantasy    |     173|
What boy.                          |Sci-Fi     |     172|
Democrat front.                    |Sci-Fi     |     168|
Point point.                       |Sci-Fi     |     163|
Yourself fear admit.               |Documentary|     163|
Message from.                      |Adventure  |     160|
Mother computer.                   |Fantasy    |     158|
Particular outside easy.           |Thriller   |     153|
Open participant painting practice.|Adventure  |     151|
Rest join upon.                    |Documentary|     151|
```
<br>

**Стало**
```
RANK|Title                              |Genre      |Duration
----+-----------------------------------+-----------+--------
   1|Man forward.                       |Adventure  |     179
   2|Phone door.                        |Action     |     178
   2|Hot recently trip.                 |Comedy     |     178
   4|Future say bad.                    |Thriller   |     176
   4|From look.                         |Horror     |     176
   4|Question myself.                   |Fantasy    |     176
   7|Hour image special.                |Fantasy    |     173
   8|What boy.                          |Sci-Fi     |     172
   9|Democrat front.                    |Sci-Fi     |     168
  10|Point point.                       |Sci-Fi     |     163
  10|Yourself fear admit.               |Documentary|     163
  12|Message from.                      |Adventure  |     160
  13|Mother computer.                   |Fantasy    |     158
  14|Particular outside easy.           |Thriller   |     153
  15|Open participant painting practice.|Adventure  |     151
  15|Rest join upon.                    |Documentary|     151
```
Обратите внимание, что фильмы с одинаковой продолжительностью получили один и тот же рейтинг, например, "Phone Door" и "Hot Recently Trip". Чтобы перейти от ```Было``` к ```Стало```, в первую очередь нужно отсортировать таблицу по убыванию продолжительности фильма. Далее нам нужно спускаться вниз построчно и "смотреть" на одно поле — **Duration** (продолжительность). В принципе, мы можем назвать эти значения окном, хотя это и не совсем так, но пока нам этого достаточно. Попробуем описать значения нашего окна: 1) это значения поля **Duration**; 2) они упорядочены по убыванию. Теперь нужно перенести эту логику на **SQL**. Взглянем для начала на запрос без оконной функции.
<br>

**Было**
```SQL
SELECT Title,
       Genre,
       Duration	      
  FROM movies
 WHERE 1 = 1
   AND EXTRACT(YEAR FROM "Release Date") = 1990
   AND EXTRACT(month FROM "Release Date") = 12
 ORDER BY Duration DESC
```
<br>

**Стало**
```
SELECT RANK() OVER (ORDER BY Duration DESC) AS RANK,
       Title,
       Genre,
       Duration	      
  FROM movies
 WHERE 1 = 1
   AND EXTRACT(YEAR FROM "Release Date") = 1990
   AND EXTRACT(month FROM "Release Date") = 12
 ORDER BY RANK, Duration DESC
 ```
В исходную конструкцию мы добавили оконную функцию RANK ``` RANK() OVER (ORDER BY Duration DESC) AS RANK ``` логика которого заключается во второй части конструкции, которая гласит, что значения нашего окна, столбца Duration, мы упорядочили по убыванию.  
___

## DENSE_RANK
Оконные функции ```RANK()``` и ```DENSE_RANK()``` используются для присвоения рангов строкам в наборе данных на основе заданных критериев. Основное отличие между ними заключается в том, как они обрабатывают одинаковые значения.  
Основные отличия:  
* ```RANK()```: Если несколько строк имеют одинаковое значение, они получают одинаковый ранг, но следующий ранг пропускается. Например, если два значения имеют ранг 1, следующий ранг будет 3, а не 2.
* ```DENSE_RANK()```: В случае одинаковых значений, они также получают одинаковый ранг, но следующий ранг не пропускается. То есть, если два значения имеют ранг 1, следующий ранг будет 2.
<br>  

**Запрос**
```
SELECT RANK() OVER (ORDER BY Duration DESC) AS RANK,
       DENSE_RANK() OVER (ORDER BY Duration DESC) AS DENSE_RANK,
       Title,
       Genre,
       Duration	      
  FROM movies
 WHERE 1 = 1
   AND EXTRACT(YEAR FROM "Release Date") = 1990
   AND EXTRACT(month FROM "Release Date") = 12
 ORDER BY RANK, Duration DESC
 LIMIT 15;
```
<br>

**Результат**
```
RANK|DENSE_RANK|Title                              |Genre      |Duration|
----+----------+-----------------------------------+-----------+--------+
   1|         1|Man forward.                       |Adventure  |     179|
   2|         2|Phone door.                        |Action     |     178|
   2|         2|Hot recently trip.                 |Comedy     |     178|
   4|         3|Future say bad.                    |Thriller   |     176|
   4|         3|From look.                         |Horror     |     176|
   4|         3|Question myself.                   |Fantasy    |     176|
   7|         4|Hour image special.                |Fantasy    |     173|
   8|         5|What boy.                          |Sci-Fi     |     172|
   9|         6|Democrat front.                    |Sci-Fi     |     168|
  10|         7|Point point.                       |Sci-Fi     |     163|
  10|         7|Yourself fear admit.               |Documentary|     163|
  12|         8|Message from.                      |Adventure  |     160|
  13|         9|Mother computer.                   |Fantasy    |     158|
  14|        10|Particular outside easy.           |Thriller   |     153|
  15|        11|Open participant painting practice.|Adventure  |     151|
```
<br>  
  
Здесь наглядно показана разница между ```RANK``` и ```DENSE_RANK```, заключающаяся в том, как они обрабатывают одинаковые значения и присваивают последующие ранги.  
  
---

## ORDER BY окна и ORDER BY запроса

Посмотрим на запрос, в котором сортировка задана внутри окна ```(ORDER BY Duration DESC)```, а также отсортирован весь запрос целиком ```ORDER BY```. Почему 2 раза?   
<br>

**Запрос**
```
SELECT DENSE_RANK() OVER (ORDER BY Duration DESC) AS DENSE_RANK,   -- сортировка в окошке
       Title,
	    Genre,
	    Duration	      
  FROM movies
 WHERE 1 = 1
   AND EXTRACT(YEAR FROM "Release Date") = 1990
   AND EXTRACT(month FROM "Release Date") = 12
 ORDER BY DENSE_RANK, Duration DESC   -- сортиовка запроса в целом
 LIMIT 15
```
<br>

**Результат**
```
DENSE_RANK|Title                              |Genre      |Duration|
----------+-----------------------------------+-----------+--------+
         1|Man forward.                       |Adventure  |     179|
         2|Phone door.                        |Action     |     178|
         2|Hot recently trip.                 |Comedy     |     178|
         3|Future say bad.                    |Thriller   |     176|
         3|From look.                         |Horror     |     176|
         3|Question myself.                   |Fantasy    |     176|
         4|Hour image special.                |Fantasy    |     173|
         5|What boy.                          |Sci-Fi     |     172|
         6|Democrat front.                    |Sci-Fi     |     168|
         7|Point point.                       |Sci-Fi     |     163|
         7|Yourself fear admit.               |Documentary|     163|
         8|Message from.                      |Adventure  |     160|
         9|Mother computer.                   |Fantasy    |     158|
        10|Particular outside easy.           |Thriller   |     153|
        11|Open participant painting practice.|Adventure  |     151|
```
<br>  
Оставим сортировку в окне но уберем в основном запросе.   

    
<br>  

**Запрос**
```
SELECT DENSE_RANK() OVER (ORDER BY Duration DESC) AS DENSE_RANK,
       Title,
       Genre,
       Duration	      
  FROM movies
 WHERE 1 = 1
   AND EXTRACT(YEAR FROM "Release Date") = 1990
   AND EXTRACT(month FROM "Release Date") = 12
 LIMIT 15
```
<br>

**Результат**
```
DENSE_RANK|Title                              |Genre      |Duration|
----------+-----------------------------------+-----------+--------+
         1|Man forward.                       |Adventure  |     179|
         2|Phone door.                        |Action     |     178|
         2|Hot recently trip.                 |Comedy     |     178|
         3|Future say bad.                    |Thriller   |     176|
         3|From look.                         |Horror     |     176|
         3|Question myself.                   |Fantasy    |     176|
         4|Hour image special.                |Fantasy    |     173|
         5|What boy.                          |Sci-Fi     |     172|
         6|Democrat front.                    |Sci-Fi     |     168|
         7|Point point.                       |Sci-Fi     |     163|
         7|Yourself fear admit.               |Documentary|     163|
         8|Message from.                      |Adventure  |     160|
         9|Mother computer.                   |Fantasy    |     158|
        10|Particular outside easy.           |Thriller   |     153|
        11|Open participant painting practice.|Adventure  |     151|
```
<br>  

Никаких изменений. Значит второй ```order by``` не нужен? Нужен, сортировка внутри окна, сортирует данные именно внутри окна. Сортировка запроса отрабатывает позже и сортирует весь запрос целиком. Рассмотрим пример. Проранжируем фильмы по убыванию длительности, но сам запрос отсортируем по ее возрастаннию.  
<br>

**Запрос**
```
SELECT DENSE_RANK() OVER (ORDER BY Duration DESC) AS DENSE_RANK,   -- в окне мы сортируем записи по убыванию Duration 
       Title,
       Genre,
       Duration	      
  FROM movies
 WHERE 1 = 1
   AND EXTRACT(YEAR FROM "Release Date") = 1990
   AND EXTRACT(month FROM "Release Date") = 12
 ORDER BY Duration   -- в запросе мы добавляем сортировку по возрастанию длительности
 LIMIT 15
```
<br>

**Результат**
```
DENSE_RANK|Title                 |Genre      |Duration|
----------+----------------------+-----------+--------+
        46|Force every fire.     |Comedy     |      67|
        45|Ago particularly.     |Fantasy    |      70|
        44|Article remain.       |Fantasy    |      75|
        43|Consider service room.|Comedy     |      79|
        42|On either there left. |Comedy     |      86|
        41|Any send.             |Documentary|      87|
        40|Some.                 |Adventure  |      88|
        39|Provide share.        |Drama      |      89|
        39|Perform peace detail. |Horror     |      89|
        38|Behind full.          |Thriller   |      90|
        38|Market shoulder also. |Fantasy    |      90|
        38|Every lay reveal.     |Comedy     |      90|
        37|Authority their.      |Drama      |      91|
        36|Line as.              |Documentary|      92|
        35|I.                    |Thriller   |      93|
```
<br>

Видно, что ранг присвоен по убыванию продолжительности, самые длинные фильмы занимают первые места в ранге, самый короткий фильм на последнем месте и длится 67 минут. А сам запрос отсортирован по возрастанию длительности и на первых строках у нас расположены самые короткие фильмы с постепенным увеличением длительности.  

---

## Однозначность сортировки  

Зачастую возникает вопрос, для каких целей в сортировку добавляют ```id```?
<br>

**Запрос**
```
SELECT DENSE_RABK() OVER (order by salary DESC) AS rank,
       name,
       department,
       salary
  FROM employees
 ORDER BY rank, id;
```
<br>

**Результат**
```
│ rank │   name   │ department │ salary │
├──────┼──────────┼────────────┼────────┤
│ 1    │ Иван     │ it         │ 120    │
│ 2    │ Леонид   │ it         │ 104    │
│ 2    │ Марина   │ it         │ 104    │
│ 3    │ Анна     │ sales      │ 100    │
│ 4    │ Вероника │ sales      │ 96     │
│ 4    │ Григорий │ sales      │ 96     │
│ 5    │ Ксения   │ it         │ 90     │
│ 6    │ Елена    │ it         │ 84     │
│ 7    │ Борис    │ hr         │ 78     │
│ 8    │ Дарья    │ hr         │ 70     │
```
<br>  

Почему используется сортировка по ```rank``` и ```id```, а не только по ```rank```? Это необходимо для того, чтобы правильно упорядочить сотрудников с одинаковым рангом. Без использования ```id``` порядок записей, таких как «Леонид-Марина» и «Вероника-Григорий», остается неопределённым, и система управления базами данных (СУБД) может разместить их в произвольном порядке. Однако при добавлении ```id``` порядок становится однозначным: «Леонид, затем Марина» и «Вероника, затем Григорий».  

___

## Секционирование окна / партиции  

Задача - составить независимый рейтинг внутри каждого жанра.  

**Было**
```
Title                              |Genre    |Duration
-----------------------------------+---------+--------
Phone door.                        |Action   |     178
Skin improve.                      |Action   |     120
Fine bed.                          |Action   |     108
Man forward.                       |Adventure|     179
Message from.                      |Adventure|     160
Open participant painting practice.|Adventure|     151
Offer expert.                      |Adventure|     109
Some.                              |Adventure|      88
Hot recently trip.                 |Comedy   |     178
Arm office charge.                 |Comedy   |     122
Full since thought machine.        |Comedy   |     122
Every lay reveal.                  |Comedy   |      90
On either there left.              |Comedy   |      86
Consider service room.             |Comedy   |      79
Force every fire.                  |Comedy   |      67
```
<br>  

**Стало** - разделение дефисами чисто косметическое, для наглядности.
```
Title                              |Genre    |Duration|DENSE_RANK
-----------------------------------+---------+--------+----------
Phone door.                        |Action   |     178|         1
Skin improve.                      |Action   |     120|         2
Fine bed.                          |Action   |     108|         3
-----------------------------------------------------------------
Man forward.                       |Adventure|     179|         1
Message from.                      |Adventure|     160|         2
Open participant painting practice.|Adventure|     151|         3
Offer expert.                      |Adventure|     109|         4
Some.                              |Adventure|      88|         5
-----------------------------------------------------------------
Hot recently trip.                 |Comedy   |     178|         1
Full since thought machine.        |Comedy   |     122|         2
Arm office charge.                 |Comedy   |     122|         2
Every lay reveal.                  |Comedy   |      90|         3
On either there left.              |Comedy   |      86|         4
Consider service room.             |Comedy   |      79|         5
Force every fire.                  |Comedy   |      67|         6
```
<br> 

Посмотрим на запрос, что позволил нам разделить результат на группы (партиции) основную таблицу.  
<br> 

**Запрос**
```
SELECT Title,
       Genre,
       Duration,
       DENSE_RANK() OVER (PARTITION BY Genre ORDER BY Duration DESC) AS RANK
  FROM movies
 WHERE 1 = 1
   AND EXTRACT(YEAR FROM "Release Date") = 1990
   AND EXTRACT(month FROM "Release Date") = 12
 ORDER BY Genre, Duration DESC
 LIMIT 15
```
<br> 

Стоит обратить внимание, что сначала мы сортируем таблицу по жанрам, а внутри жанра по убыванию длительности. Видно, что "окно" меняется в зависимости от жанра.  
```PARTITION BY Genre``` - само окно разбито на секции в зависимости от принадлежности к жанру - по одной секции окна на жанр.  
```ORDER BY Duration DESC``` - внутри секции упорядочены по убыванию длительностию.  
```DENSE_RANK()``` - функция ранжирования нам уже известна.    
В результате получаем вот такую конструкцию ```DENSE_RANK() OVER (PARTITION BY Genre ORDER BY Duration DESC)```, которая позволяет разделить окно на отдельные секции благодаря ```PARTITION BY```.  

---

## NTILE - группы

Задача - разделить фильмы по длительности на три группы: длинные фильмы, средней продолжительности и самые короткие.  
<br>  

**Было***
```
Title                              |Genre      |Duration
-----------------------------------+-----------+--------
There someone somebody.            |Sci-Fi     |     135
I.                                 |Thriller   |      93
Phone scene wide.                  |Romance    |     137
Whether officer road.              |Documentary|     139
Those every word.                  |Thriller   |     145
Behind full.                       |Thriller   |      90
Man forward.                       |Adventure  |     179
Message from.                      |Adventure  |     160
Any send.                          |Documentary|      87
Tax give guy.                      |Sci-Fi     |     111
Democrat front.                    |Sci-Fi     |     168
Authority their.                   |Drama      |      91
Nothing religious particularly.    |Thriller   |     134
Open participant painting practice.|Adventure  |     151
Mother computer.                   |Fantasy    |     158
```
<br> 

**Стало**  
```
Title                              |Genre      |Duration|Group
-----------------------------------+-----------+--------+-----
Man forward.                       |Adventure  |     179|    1
Democrat front.                    |Sci-Fi     |     168|    1
Message from.                      |Adventure  |     160|    1
Mother computer.                   |Fantasy    |     158|    1
Open participant painting practice.|Adventure  |     151|    1
--------------------------------------------------------------
Those every word.                  |Thriller   |     145|    2
Whether officer road.              |Documentary|     139|    2
Phone scene wide.                  |Romance    |     137|    2
There someone somebody.            |Sci-Fi     |     135|    2
Nothing religious particularly.    |Thriller   |     134|    2
--------------------------------------------------------------
Tax give guy.                      |Sci-Fi     |     111|    3
I.                                 |Thriller   |      93|    3
Authority their.                   |Drama      |      91|    3
Behind full.                       |Thriller   |      90|    3
Any send.                          |Documentary|      87|    3
```
<br>   

Как перейти от **Было** к **Стало**? Для начала стоит отсортировать таблицу, например, по убыванию длительности. Всего 15 записей, 3 группы, значит, по 5 фильмов в группе. Чтобы провести границы между группами, придется анализировать продолжительность, отсортированную по убыванию. Поэтому окно будет таким: ```(ORDER BY Duration DESC)``` а вот сама оконная функция будет другая - ```NTILE(n)```, где ```n``` - количество групп.
<br>  

**Запрос**
```
SELECT Title,
	   Genre,
	   Duration, 
	   NTILE(3) OVER (ORDER BY Duration DESC) AS group
  FROM movie 
 ORDER BY Duration DESC
```
Функция ```NTILE(n)``` делит все записи на ```n``` групп и возвращает номер группы для каждой записи. Если бы общее количество записей составляло не 15 (как у нас), а, например, 14, при этом групп все равно остается 3, то первые группы были бы больше по количеству записей, чем последние.  
Функция ```NTILE()``` стремится разбить данные так, чтобы группы были равного размера. Поэтому записи с одинаковым значением зарплаты могут оказаться в разных (соседних) группах.

--

## ROW_NUMBER

Задача - избаиться от дубликатов записей по столбцу. Предположим, что вместо длительности у нас будут ```id```. В таком случае каждое значение должно быть уникальным. 
<br>  

**Было** - секциями выделил повторяющиеся записи по полю ```Duration```. 
```
Duration|row_number|
--------+----------+
     179|         1|
--------------------
     178|         1|
     178|         2|
--------------------
     176|         1|
     176|         2|
     176|         3|
--------------------
     173|         1|
     172|         1|
     168|         1|
--------------------
     163|         1|
     163|         2|
-------------------
     160|         1|
     158|         1|
     153|         1|
```
<br> 

**Стало** - остались только уникальные записи
```
Genre      |Duration|row_number|
-----------+--------+----------+
Adventure  |     179|         1|
Action     |     178|         1|
Thriller   |     176|         1|
Fantasy    |     173|         1|
Sci-Fi     |     172|         1|
Sci-Fi     |     168|         1|
Sci-Fi     |     163|         1|
Adventure  |     160|         1|
Fantasy    |     158|         1|
Thriller   |     153|         1|
Adventure  |     151|         1|
Thriller   |     148|         1|
Thriller   |     145|         1|
Romance    |     144|         1|
```
<br> 

Как перейти от **Было** к **Стало**?  
Проанализиуем запрос.  
<br> 

**Запрос**
```
  WITH movie AS (
SELECT Title,
       Genre,
       Duration,
       ROW_NUMBER() OVER (PARTITION BY Duration ORDER BY Duration DESC) AS row_number
  FROM movies
 WHERE 1 = 1
   AND EXTRACT(YEAR FROM "Release Date") = 1990
   AND EXTRACT(month FROM "Release Date") = 12)
 
SELECT Genre,
       Duration,
       row_number
  FROM movie
 WHERE ROW_NUMBER = 1
 ORDER BY Duration DESC
```
<br>  

Первое, на что стоит обратить внимание, — это оконная функция ```ROW_NUMBER()```. В части ```(PARTITION BY Duration)``` мы явно указываем, что необходимо создать окно по полю ```Duration``` (или ```id)```.  
Второй важный момент — это использование общего табличного выражения (CTE), которое позволяет в основном запросе оставить только уникальные записи благодаря фильтрации ```WHERE row_number = 1```. Это решение идеально работает, поскольку внутри окна одинаковым значениям ```row_number()``` присваиваются номера строк по возрастанию. 

---

# Функции смещения
<br>

## LAG / LEAD - сравнение со смещением

Упорядочим фильмы по возрастанию длительности и проверим, насколько каждый последующий фильм длиннее в минутах и процентах.  
<br>  
  
**Результат**
```
Title                 |Duration|Diff_min|DIff_prc|LAG
----------------------+--------+--------+--------+---
Force every fire.     |      67|        |        |   
Ago particularly.     |      70|       3|     4.5| 67
Article remain.       |      75|       5|     7.1| 70
Consider service room.|      79|       4|     5.3| 75
On either there left. |      86|       7|     8.9| 79
Any send.             |      87|       1|     1.2| 86
Some.                 |      88|       1|     1.1| 87
Provide share.        |      89|       1|     1.1| 88
Perform peace detail. |      89|       0|     0.0| 89
Behind full.          |      90|       1|     1.1| 89
Market shoulder also. |      90|       0|     0.0| 90
Every lay reveal.     |      90|       0|     0.0| 90
Authority their.      |      91|       1|     1.1| 90
Line as.              |      92|       1|     1.1| 91
I.                    |      93|       1|     1.1| 92
```
<br>  
 
 Внимательно взглянем на таблицу. Помимо Базовых полей ```Title``` и ```Duration``` у нас появились расчетные поля, такие как ```LAG```, которое отображает предыдущее значение по полю ```Duration```, а также поля ```Diff_min``` и ```Diff_prc```, содержащие разницу в минутах и процентах между текущей записью и предшествующей по полю ```Duration```.   
 Закончив рассмотрение результирующей таблицы можем перейти к разбору самого запроса.  
<br>  
  
 **Запрос**
```
  WITH movie AS (
SELECT Title,
       Genre,
       Duration,
       LAG(Duration) OVER (ORDER BY Duration) AS LAG,
       Duration - LAG(Duration) OVER (ORDER BY Duration) AS Diff_min,
       ROUND((Duration / LAG(Duration) OVER (ORDER BY Duration) - 1) * 100,1) AS DIff_prc
       FROM movies
 WHERE 1 = 1
   AND EXTRACT(YEAR FROM "Release Date") = 1990
   AND EXTRACT(month FROM "Release Date") = 12
 ORDER BY Duration ASC 
 LIMIT 15)

SELECT Title,
       Duration,
       Diff_min,
       DIff_prc,
       LAG
  FROM movie 
```
<br>    

Функция ```LAG``` возвращает значение указанного поля с заданным смещением назад. Это смещение можно указывать явно, что позволяет контролировать, на сколько строк назад будет производиться поиск значения.   
```
LAG(Duration) OVER (ORDER BY Duration) AS LAG          -- смещение на одну строку назад, можно не указыватьколичество строк для смещения  
LAG(Duration, 3) OVER (ORDER BY Duration) AS "LAG-3"   -- смещение на 3 строки назад, явно задается в LAG( ... , 3)
```
<br> 

```
Title                 |Duration|LAG|LAG-3|
----------------------+--------+---+-----+
Force every fire.     |      67|   |     |
Ago particularly.     |      70| 67|     |
Article remain.       |      75| 70|     |
Consider service room.|      79| 75|   67|
On either there left. |      86| 79|   70|
Any send.             |      87| 86|   75|
Some.                 |      88| 87|   79|
Provide share.        |      89| 88|   86|
Perform peace detail. |      89| 89|   87|
Behind full.          |      90| 89|   88|
Market shoulder also. |      90| 90|   89|
Every lay reveal.     |      90| 90|   89|
Authority their.      |      91| 90|   90|
Line as.              |      92| 91|   90|
I.                    |      93| 92|   90|
```
<br>   
  
Теперь, как не сложно уже догадаться мы можем легко найти абсолютную и относительную разницу для сравнения со смещением.  
```
Duration - LAG(Duration) OVER (ORDER BY Duration) AS Diff_min			    -- абсолютное изменение									
ROUND((Duration / LAG(Duration) OVER (ORDER BY Duration) - 1) * 100,1) AS DIff_prc  -- относительное изменение, с окргуглением до одного знака после запятой
```

Аналогичным образом работает функция ```LEAD```, меняетя только направление просмотра. Функция смотрит не "назад" а "вперед". В остальном все то же.

---
<br>  

## LAST_VALUE / FIRST_VALUE - сравнение с границами  
  
А теперь предположим, что мы хотим сравнить значение с самым большим или самым маленьким в группе.  Как перейти от **Было** к **Стало**?  
<br>

**Было**
```
Title                              |Genre    |Duration
-----------------------------------+---------+--------
Phone door.                        |Action   |     178
Skin improve.                      |Action   |     120
Fine bed.                          |Action   |     108
Man forward.                       |Adventure|     179
Message from.                      |Adventure|     160
Open participant painting practice.|Adventure|     151
Offer expert.                      |Adventure|     109
Some.                              |Adventure|      88
Hot recently trip.                 |Comedy   |     178
Arm office charge.                 |Comedy   |     122
Full since thought machine.        |Comedy   |     122
Every lay reveal.                  |Comedy   |      90
On either there left.              |Comedy   |      86
Consider service room.             |Comedy   |      79
Force every fire.                  |Comedy   |      67
```
<br>  

Тут все предельно просто, сортируем по жанрам, затем добавляем сортировку по продолжительности по убыванию. Наша задача же создать окно с минимальным и максимальным значением продолжительности с жанрами в качестве партиций.  Пишем запрос...  
<br>  


```
SELECT Title,
       Genre,
       Duration,
       FIRST_VALUE (Duration) OVER (PARTITION BY Genre ORDER BY Duration) AS Min,
       LAST_VALUE (Duration) OVER (PARTITION BY Genre ORDER BY Duration) AS Max
       FROM movies
 WHERE 1 = 1
   AND EXTRACT(YEAR FROM "Release Date") = 1990
   AND EXTRACT(month FROM "Release Date") = 12
 ORDER BY Genre, Duration DESC 
 LIMIT 15
```
<br>  

Как не трудно догадаться оконные функции ```FIRST_VALUE``` и ```LAST_VALUE``` возвращают минимальное и максимальное значении в партиции, в данном случае это жанр. ```(PARTITION BY Genre ORDER BY Duration)```.  
<br>  

**Результат**
```
Title                              |Genre    |Duration|Min|Max|
-----------------------------------+---------+--------+---+---+
Phone door.                        |Action   |     178|108|178|
Skin improve.                      |Action   |     120|108|120|
Fine bed.                          |Action   |     108|108|108|
---------------------------------------------------------------
Man forward.                       |Adventure|     179| 88|179|
Message from.                      |Adventure|     160| 88|160|
Open participant painting practice.|Adventure|     151| 88|151|
Offer expert.                      |Adventure|     109| 88|109|
Some.                              |Adventure|      88| 88| 88|
---------------------------------------------------------------
Hot recently trip.                 |Comedy   |     178| 67|178|
Arm office charge.                 |Comedy   |     122| 67|122|
Full since thought machine.        |Comedy   |     122| 67|122|
Every lay reveal.                  |Comedy   |      90| 67| 90|
On either there left.              |Comedy   |      86| 67| 86|
Consider service room.             |Comedy   |      79| 67| 79|
Force every fire.                  |Comedy   |      67| 67| 67|
```
<br>  

Как можем видеть, минимум определился верно а вот с максимумо какая-то ерунда. Разберемся, почему так произошло. Ведь запрос на первый взгляд написан корректно.  

### Фреймы  
До сих пор все было нормлаьно, есть окно, внутри окна есть артиции, упорядоченные по определенному столбцу. На предыдущем шаге мы разделили окно на три партиции по жанрам: Actrion, Adventure, Comdey.  
<br>  

```
Duration
--------+

Action
--------+
     178|
     120|
     108|
--------+

Adventure
--------+
     179|  - LAST_VALUE
     160|
     151|
     109|
      88|  - FIRST_VALUE
--------+

Comedy
--------+
     178|
     122|
     122|
      90|
      86|
      79|
      67|
--------+
```
<br>  

Так почему же функции ```LAST_VALUE``` и ```FIRST_VALUE``` могут отображать информацию некорректно? Все дело в том, что эти функции работают не только с партицией внутри окна, но также и с фреймом внутри партиции.  Партиция зафиксирована, а вот фрейм зависит от положения текущей записи внутри партиции и постоянно меняется. Фрейм определяет, какие строки будут учитываться при вычислении значения для текущей строки. Если границы фрейма не заданы, то по умолчанию фрейм будет ограничен текущей строкой и строками, которые находятся до и после нее, что может привести к неожиданным результатам. Можно упомянуть, что функции ```LEAD``` и ```LAG``` также работают с соседними строками, но они не зависят от фреймов.  

Функция ```FIRST_VALUE``` возвращает первую строку фрейма, которая совпадает с началом партиции. Именно благодаря этому она отрабатывает корректно.   
Чтобы функция ```LAST_VALUE``` также отрабатывала правильно, мы должны явно задать границы фрейма внутри партиции. К счастью, это делается довольно просто: нужно всего лишь добавить ```ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING```.  
Изменим запрос и посмотрим на результат.  
<br>

**Запрос**  
```
SELECT Title,
       Genre,
       Duration,
       FIRST_VALUE (Duration) OVER (PARTITION BY Genre ORDER BY Duration ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS Min,
       LAST_VALUE (Duration) OVER (PARTITION BY Genre ORDER BY Duration ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS Max
       FROM "movies db".main.Movies
 WHERE 1 = 1
   AND EXTRACT(YEAR FROM "Release Date") = 1990
   AND EXTRACT(month FROM "Release Date") = 12
 ORDER BY Genre, Duration DESC 
 LIMIT 15
```
<br>  

**Результат**
```
Title                              |Genre    |Duration|Min|Max|
-----------------------------------+---------+--------+---+---+
Phone door.                        |Action   |     178|108|178|
Skin improve.                      |Action   |     120|108|178|
Fine bed.                          |Action   |     108|108|178|
---------------------------------------------------------------
Man forward.                       |Adventure|     179| 88|179|
Message from.                      |Adventure|     160| 88|179|
Open participant painting practice.|Adventure|     151| 88|179|
Offer expert.                      |Adventure|     109| 88|179|
Some.                              |Adventure|      88| 88|179|
---------------------------------------------------------------
Hot recently trip.                 |Comedy   |     178| 67|178|
Arm office charge.                 |Comedy   |     122| 67|178|
Full since thought machine.        |Comedy   |     122| 67|178|
Every lay reveal.                  |Comedy   |      90| 67|178|
On either there left.              |Comedy   |      86| 67|178|
Consider service room.             |Comedy   |      79| 67|178|
Force every fire.                  |Comedy   |      67| 67|178|
```
<br>  

После явного указания фреймов наши функции ```FIRST_VALUE``` и ```LAST_VALUE``` отрабатывают как и задумано.  
<br>   

Фрейм определяется в общем случае так ```rows between X preceding and Y following```  
Где ```X``` — количество строк перед текущей, а ```Y``` — количество строк после текущей.  
* Если указать вместо ```X``` или ```Y``` значение ```unbounded``` — это значит «граница секции».
* Если указать вместо ```X``` preceding или ```Y``` following значение ```current row``` — это значит «текущая запись».

**Фрейм никогда не выходит за границы секции, если столкнулся с ней — обрезается.** Подробнее это мы рассмотрим на расчете суммы нарастающим итогом.  

Запрос без явного указания фрейма все равно вычислил бы кумулятивную длительность, точно так же, как и запрос с фреймом. Как это возможно?  
Дело в том, что в окне присутствует сортировка (ORDER BY Duartion). Существует правило:  
* если в окне задан ```ORDER BY```,  
* и используется агрегатная функция,  
* и определение фрейма не указано,  
* то применяется фрейм по умолчанию.

В нашем случае фрейм по умолчанию охватывает диапазон от первой до текущей записи. Поэтому результаты совпадают с теми, что получены в запросе, где фрейм был явно указан (```ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW```).  
Однако это не всегда так. Так что фреймы лучше указывать явно, чтобы избежать неожиданностей.

---

<br>

## NTH_VALUE 
Функция NTH_VALUE является оконной функцией, которая позволяет извлекать значение из N-й строки в упорядоченном наборе данных. Предположим, нам нужно выбрать третий по продолжительности фильм в каждой группе. Чтобы получить результат как в примере нам потребуется воспользоваться функцией ```NTH_VALUE```. Функция принимает два параметра. Первый параметр определяет выражение или столбец, из которого нужно получить значение для N-й строки. Второй параметр указывает порядковый номер строки, значение которой нужно вернуть. Он должен быть положительным целым числом.  
<br>  

**Результат**  
```
Title                              |Genre    |Duration|nth|
-----------------------------------+---------+--------+---+
Phone door.                        |Action   |     178|108|
Skin improve.                      |Action   |     120|108|
Fine bed.                          |Action   |     108|108|
----------------------------------------------------------
Man forward.                       |Adventure|     179|151|
Message from.                      |Adventure|     160|151|
Open participant painting practice.|Adventure|     151|151|
Offer expert.                      |Adventure|     109|151|
Some.                              |Adventure|      88|151|
----------------------------------------------------------
Hot recently trip.                 |Comedy   |     178|122|
Full since thought machine.        |Comedy   |     122|122|
Arm office charge.                 |Comedy   |     122|122|
Every lay reveal.                  |Comedy   |      90|122|
On either there left.              |Comedy   |      86|122|
Consider service room.             |Comedy   |      79|122|
Force every fire.                  |Comedy   |      67|122|
```
<br>  

В результирующем наборе мы получили поле, в котором содержится третья запись поля ```Duration```, отсортированного по убыванию. Как это выглядит в запросе?  
<br>  

**Запрос**
```
SELECT Title,
       Genre,
       Duration,
       NTH_VALUE (Duration, 3) OVER (PARTITION BY Genre ORDER BY Duration DESC ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS nth
  FROM movies
 WHERE 1 = 1
   AND EXTRACT(YEAR FROM "Release Date") = 1990
   AND EXTRACT(month FROM "Release Date") = 12
 ORDER BY Genre, Duration DESC 
 LIMIT 15
```
<br>  

В фрагменте запроса ```NTH_VALUE (Duration, 3)``` мы задаем поле, по которому необходимо произвести просмотр, а также вторым аргументом указываем степень смещения. В данном случае 3 строки.   
```(PARTITION BY Genre ORDER BY Duration DESC ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING``` - определяем партицию, это жанр. Дальше явно указываем фрейм и сортировку.  

---

# Агрегатные функции  

<br>  

## SUM  
<br>  

В нашем кейсе есть таблица, содержащая фонд оплаты труда всего отдела. Нужно понять, какую долю занимает фонд оплаты труда конкретного отдела в общей массе.  
<br>  

**Результат**  
```
Job Title                |sum_of_salary|prc |
-------------------------+-------------+----+
Web Developer            |      1187500|36.5|
Mobile Developer         |       857500|26.3|
DevOps Engineer          |       454000|13.9|
Machine Learning Engineer|       239500| 7.4|
Tester                   |       205500| 6.3|
Designer                 |       151000| 4.6|
HR Manager               |        98500| 3.0|
Project Manager          |        62500| 1.9|
```  
<br>  

Именно то, что нам и нужно. Как это рассчитать? Посмотрим на запрос.  
<br>  

```
  WITH cte AS (
SELECT "Job Title",
       SUM(Salary) AS sum_of_salary
  FROM employee 
 GROUP BY "Job Title"
 ORDER BY sum_of_salary DESC)
 
SELECT "Job Title",
       sum_of_salary,
       ROUND(sum_of_salary * 100.0 / SUM(sum_of_salary) OVER (), 1) AS prc
  FROM cte
```
<br>  

Вполне ожидаемо, что агрегация в оконных функция, будь то ```SUM``` или же ```MIN```, ```MAX```, ```AVG``` или ```COUNT``` отрабатывают без неожиданностей, разве, что действуют внутри секции окна.  
```SUM(sum_of_salary)``` - возвращает сумму значений окна, конкретно здесь возвращается сумма всего окна, тк секционирование в данном случае нам не требуется. На этапе создания cte мы уже сагрегировали зарплаты по отделам.   
``` OVER ()``` - дробление окна на парцтии, фреймы и сортировка нам в данном случае не потребуются.  
Осталось округлить результат до одного знака после запятой используя ```ROUND(..., 1)```. 

---

## AVG 
<br>  

Задача заключается в том, чтобы рассчитать среднюю зарплату в каждом департаменте, а также определить, насколько зарплата конкретного сотрудника отклоняется от среднего значения как в абсолютном, так и в относительном выражении.  
<br>  

**Результат**  
```
Name   |Job Title      |Salary|AVG    |diff   |diff_prc
-------+---------------+------+-------+-------+--------
Tammy  |HR Manager     | 14000|11500.0| 2500.0|    21.7
Daniel |HR Manager     | 12500|11500.0| 1000.0|     8.7
Andrew |HR Manager     | 11000|11500.0| -500.0|    -4.3
Angela |HR Manager     | 10000|11500.0|-1500.0|   -13.0
Brett  |HR Manager     | 10000|11500.0|-1500.0|   -13.0
-------------------------------------------------------
Shawn  |Project Manager| 17000|12500.0| 4500.0|    36.0
Sean   |Project Manager| 14500|12500.0| 2000.0|    16.0
Dana   |Project Manager| 12000|12500.0| -500.0|    -4.0
Joshua |Project Manager| 10500|12500.0|-2000.0|   -16.0
Jose   |Project Manager|  8500|12500.0|-4000.0|   -32.0
-------------------------------------------------------
Melanie|Web Developer  | 14500|14400.0|  100.0|     0.7
James  |Web Developer  | 14500|14400.0|  100.0|     0.7
Michael|Web Developer  | 14500|14400.0|  100.0|     0.7
April  |Web Developer  | 14500|14400.0|  100.0|     0.7
Brandy |Web Developer  | 14000|14400.0| -400.0|    -2.8
```
<br>  

Хотелось бы получить вот такой результат. Как этого добиться? Давайте рассмотрим запрос.  

**Запрос**
```
SELECT Name,
       "Job Title",
	Salary,
	AVG(Salary) OVER (PARTITiON BY "Job Title") AS AVG,
	Salary - AVG(Salary) OVER (PARTITiON BY "Job Title") AS diff,
	ROUND(Salary * 100/ AVG(Salary) OVER (PARTITiON BY "Job Title") - 100, 1) AS diff_prc
   FROM employee_v
  ORDER BY "Job Title", Salary DESC
```
<br>  

Из таблицы мы возвращаем три колонки: ```Name```, ```"Job Title"``` и ```Salary```. Затем рассчитываем еще три поля:  
* ```AVG``` как ```AVG(Salary) OVER (PARTITiON BY "Job Title")``` - просто находим среднее значение внутри патриции окна, в качестве партиции указываем департамент "Job Title";  
* ```diff``` как ```Salary - AVG(Salary) OVER (PARTITiON BY "Job Title")``` - ищем абсолютное отклонение от среднего значения, которое рассчитали на предыдущем шаге;  
* ```diff_prc``` как ```ROUND(Salary * 100 / AVG(Salary) OVER (PARTITiON BY "Job Title") - 100, 1)``` - находим относительное отклонение, округляем доя одного знака после запятой.

---
<br>  

## MIN / MAX / COUNT

Здесь без откровений, минимальное и максимальное значение, количество строк (можно вместе с ```distinct```) в секции или окне.  

**Запрос**
```
SELECT Name,
       "Job Title",
       Salary,
       MIN(Salary) OVER (PARTITiON BY "Job Title") AS min_value,
       MAX(Salary) OVER (PARTITiON BY "Job Title") AS max_value,
       COUNT(Salary) OVER (PARTITiON BY "Job Title") AS cnt_val,
       COUNT(DISTINCT "Job Title") OVER (PARTITiON BY "Job Title") AS cnt_dist_name,
  FROM employee_v
 ORDER BY "Job Title", Salary DESC
```
<br>  

**Результат**
```
Name   |Job Title      |Salary|min_value|max_value|cnt_val|cnt_dist_val|
-------+---------------+------+---------+---------+-------+-------------+
Tammy  |HR Manager     | 14000|    10000|    14000|      5|            1|
Daniel |HR Manager     | 12500|    10000|    14000|      5|            1|
Andrew |HR Manager     | 11000|    10000|    14000|      5|            1|
Angela |HR Manager     | 10000|    10000|    14000|      5|            1|
Brett  |HR Manager     | 10000|    10000|    14000|      5|            1|
Shawn  |Project Manager| 17000|     8500|    17000|      5|            1|
Sean   |Project Manager| 14500|     8500|    17000|      5|            1|
Dana   |Project Manager| 12000|     8500|    17000|      5|            1|
Joshua |Project Manager| 10500|     8500|    17000|      5|            1|
Jose   |Project Manager|  8500|     8500|    17000|      5|            1|
Melanie|Web Developer  | 14500|    14000|    14500|      5|            1|
James  |Web Developer  | 14500|    14000|    14500|      5|            1|
Michael|Web Developer  | 14500|    14000|    14500|      5|            1|
April  |Web Developer  | 14500|    14000|    14500|      5|            1|
Brandy |Web Developer  | 14000|    14000|    14500|      5|            1|
```
---
<br>

## GROUP_CONCAT 

**Было**
```
Job Title      |Name   |
---------------+-------+
HR Manager     |Tammy  |
HR Manager     |Daniel |
HR Manager     |Andrew |
HR Manager     |Angela |
HR Manager     |Brett  |
------------------------
Project Manager|Shawn  |
Project Manager|Sean   |
Project Manager|Dana   |
Project Manager|Joshua |
Project Manager|Jose   |
------------------------
Web Developer  |Melanie|
Web Developer  |James  |
Web Developer  |Michael|
Web Developer  |April  |
Web Developer  |Brandy |
```
<br>  

**Стало**
```
Job Title      |goup_name                             |
---------------+--------------------------------------+
HR Manager     |Tammy, Daniel, Andrew, Angela, Brett  |
Project Manager|Shawn, Sean, Dana, Joshua, Jose       |
Web Developer  |Melanie, James, Michael, April, Brandy|      
```
<br>  

**Запрос**
```
-- Было
SELECT "Job Title",
       Name
  FROM employee_v

-- Стало
SELECT "Job Title",
       GROUP_CONCAT(Name, ', ') AS goup_name
  FROM employee_v
 GROUP BY "Job Title"
```
---
<br>

# Скользящие агрегаты

## Скользящее среднее

Скользящее среднее — это статистический метод анализа данных, который используется для сглаживания временных рядов и выявления тенденций. Оно вычисляется путем усреднения значений в заданном окне (диапазоне) данных. Скользящее среднее помогает сгладить флуктуации и колебания в данных, делая тенденции более очевидными.
Скользящее среднее рассчитывается путем суммирования значений в заданном окне и деления на количество значений в этом окне. Рассмотрим пример, в котором система управления базами данных (СУБД) будет учитывать текущую строку, а также предшествующую и следующую за ней. Например, скользящее среднее за февраль будет рассчитано как сумма данных за январь, февраль и март, разделенная на 3.
<br>

**Было**
```
year|month|duration|
----+-----+--------+
2018|    1| 10206.0|
2018|    2| 23146.0|
2018|    3| 45434.0|
2018|    4| 62531.0|
2018|    5| 83771.0|
2018|    6| 99250.0|
2018|    7|124373.0|
2018|    8|145072.0|
2018|    9|163724.0|
2018|   10|183068.0|
2018|   11|198207.0|
2018|   12|230010.0|
```
<br>

**Стало**
```
year|month|duration|roll_avg|
----+-----+--------+--------+
2018|    1| 10206.0| 16676.0|
2018|    2| 23146.0| 26262.0|
2018|    3| 45434.0| 43704.0|
2018|    4| 62531.0| 63912.0|
2018|    5| 83771.0| 81851.0|
2018|    6| 99250.0|102465.0|
2018|    7|124373.0|122898.0|
2018|    8|145072.0|144390.0|
2018|    9|163724.0|163955.0|
2018|   10|183068.0|181666.0|
2018|   11|198207.0|203762.0|
2018|   12|230010.0|214108.0|
```
<br>

**Запрос**
```
  WITH cte AS(
SELECT EXTRACT(year FROM call_date::date) AS YEAR,
       EXTRACT(month FROM call_date::date) AS MONTH,
       ROUND(SUM(duration)) AS duration
  FROM public.calls
 GROUP BY YEAR, MONTH)
 
 SELECT YEAR,
        MONTH,
 	duration,
 	ROUND(AVG(duration) OVER (ORDER BY YEAR, MONTH ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING)) AS roll_avg
   FROM cte
  ORDER BY YEAR, MONTH
```
<br>  

Окно состоит из одной секции (в нашем случае — всех записей ```duration```), упорядоченных по столбцам (```year```, ```month```). Каждая запись имеет свой фрейм, который на каждом шаге охватывает три записи: текущую, предыдущую и следующую.  
<br>  

```
ORDER BY year, month	-- ORDER BY устанавливает порядок сортировки.
ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING	-- определяет фрейм: «выбрать строки от одной предыдущей до одной следующей»
```
---
<br>  

## Сумма нарастающим итогом

Фрейм определяется в общем случае так ```rows between X preceding and Y following```  
Где ```X``` — количество строк перед текущей, а ```Y``` — количество строк после текущей.  
* Если указать вместо ```X``` или ```Y``` значение ```unbounded``` — это значит «граница секции».
* Если указать вместо ```X``` preceding или ```Y``` following значение ```current row``` — это значит «текущая запись».

**Фрейм никогда не выходит за границы секции, если столкнулся с ней — обрезается.** Подробнее это мы рассмотрим на расчете суммы нарастающим итогом.

**Резульата**
```
Name   |Job Title      |Salary|sum_of_salary| - Сумма нарастающим итогом
-------+---------------+------+-------------+
Tammy  |HR Manager     | 14000|        14000| <- UNBOUNDED PRECEDING 
Daniel |HR Manager     | 12500|        26500| = 14 000 + 12 500 
Andrew |HR Manager     | 11000|        37500| ...
Angela |HR Manager     | 10000|        47500| ...
Brett  |HR Manager     | 10000|        57500| = 14 000 + 12 500 + 11 000 + 10 000 + 10 000
---------------------------------------------
Shawn  |Project Manager| 17000|        17000| <- UNBOUNDED PRECEDING 
Sean   |Project Manager| 14500|        31500|
Dana   |Project Manager| 12000|        43500|
Joshua |Project Manager| 10500|        54000|
Jose   |Project Manager|  8500|        62500|
---------------------------------------------
Melanie|Web Developer  | 14500|        14500| <- UNBOUNDED PRECEDING 
James  |Web Developer  | 14500|        29000|
Michael|Web Developer  | 14500|        43500|
April  |Web Developer  | 14500|        58000|
Brandy |Web Developer  | 14000|        72000|
```
<br>  

**Запрос**
```
 SELECT Name,
        "Job Title",
         Salary,
 	 SUM(Salary) OVER (PARTITION BY "Job Title" ORDER BY Salary DESC ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS sum_of_salary
   FROM "duckdb test".main.employee_v
  ORDER BY "Job Title", Salary DESC;
```
---
<br>  

# Фреймы  

**Фрейм** представляет собой набор записей, с которым в данный момент взаимодействует оконная функция.  
В общем виде определение фрейма выглядит так:  
```ROWS BETWEEN frame_start AND frame_end```  
<br>  

Начало фрейма (frame_start) может быть задано следующими способами:  
* ```current row``` — начинается с текущей строки;  
* ```N preceding``` — начинается с N-й строки перед текущей;  
* ```N following``` — начинается с N-й строки после текущей;  
* ```unbounded preceding``` — начинается с начала секции.  
<br>  

Аналогично, конец фрейма (frame_end) может быть определен как:  
* ```current row``` — до текущей строки;  
* ```N preceding``` — до N-й строки перед текущей;  
* ```N following``` — до N-й строки после текущей;  
* ```unbounded following``` — до конца секции.
<br>

Не все функции поддерживают фреймы:
* функции смещения ```first_value()```, ```last_value()```, ```nth_value()```;  
* все функции агрегации: ```count()```, ```avg()```, ```sum()```, ...
<br>

Другие функции не поддерживают фреймы. Они действуют на всю секцию (```partition by```), а если секция не указана, то применяются ко всем выбранным записям.  

---
<br>  

## GROUPS-фреймы  
<br>  

До этого момента мы использовали следующее определение фрейма:  
```ROWS BETWEEN frame_start AND frame_end```
<br>
На самом деле, помимо фрейма по строкам (ROWS), существуют еще фреймы по группам (GROUPS) и диапазону (RANGE):
* ```ROWS BETWEEN frame_start AND frame_end```;  
* ```GROUPS BETWEEN frame_start AND frame_end```;   
* ```RANGE BETWEEN frame_start AND frame_end```.  
---

### GROUPS BETWEEN  
<br>  

Начнем рассмотрение с фрейма **GROUPS**. Обратимся к таблице с сотрудниками и посчитаем количество нарастающим итогом.  
<br>  

**Результат**  
```
┌──────────┬────────────┬─────┐
│   name   │ department │ cnt │
├──────────┼────────────┼─────┤
│ Дарья    │ hr         │ 1   │
│ Борис    │ hr         │ 2   │
├──────────┼────────────┼─────┤
│ Елена    │ it         │ 3   │
│ Ксения   │ it         │ 4   │
│ Леонид   │ it         │ 5   │
│ Марина   │ it         │ 6   │
│ Иван     │ it         │ 7   │
├──────────┼────────────┼─────┤
│ Вероника │ sales      │ 8   │
│ Григорий │ sales      │ 9   │
│ Анна     │ sales      │ 10  │
└──────────┴────────────┴─────┘

```
<br>  

**Запрос**
```
 SELECT name,
        department,
        count(*) OVER (ORDER BY department ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS cnt
   FROM employees
  ORDER BY department, id;
```
<br>  

А теперь давайте заменим **ROWS** на **GROUPS** в определении фрейма и посомтрим на результат запроса.  
<br>  

**Запрос**  
```
 SELECT name,
        department,
        count(*) OVER (ORDER BY department GROUPS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS cnt
   FROM employees
  ORDER BY department, id;
```
<br>  

**Результат**
```
┌──────────┬────────────┬─────┐
│   name   │ department │ cnt │
├──────────┼────────────┼─────┤
│ Дарья    │ hr         │ 2   │
│ Борис    │ hr         │ 2   │
├──────────┼────────────┼─────┤
│ Елена    │ it         │ 7   │
│ Ксения   │ it         │ 7   │
│ Леонид   │ it         │ 7   │
│ Марина   │ it         │ 7   │
│ Иван     │ it         │ 7   │
├──────────┼────────────┼─────┤
│ Вероника │ sales      │ 10  │
│ Григорий │ sales      │ 10  │
│ Анна     │ sales      │ 10  │
└──────────┴────────────┴─────┘
```
<br>  

Ключевое отличие заключается в том, что **ROWS-фрейм** работает с отдельными записями, в то время как **GROUPS-фрейм** оперирует группами записей, у которых значение столбца, указанного в ```ORDER BY``` (в нашем случае — департамент), совпадает.  
<br>  

В обоих случаях запрос на каждом шаге считает количество записей нарастающим итогом: от начала до конца фрейма. Но у **ROWS** фрейм заканчивается на текущей записи, а у **GROUPS** — на последней записи текущей группы. Поскольку групп всего три (hr — 2 записи, it — 5 записей, sales — 3 записи), то фрейм смещается «рывками»:  

* ```count(*)``` для hr → 2 записи  
* ```count(*)``` для hr + it → 7 записей  
* ```count(*)``` для hr + it + sales → 10 записей
  
Инструкции для границ группового фрейма используются такие же, как для строкового, но смысл их отличается:   
<br>

```current row``` — текущая группа (а не текущая строка);  
```N preceding / following``` — N-я группа относительно текущей (а не N-я строка);  
```unbounded preceding / following``` — граница секции (как у строкового фрейма).  
Групповые фреймы поддерживаются в PostgreSQL, SQLite и Oracle 21c+, но не в MySQL и SQL Server.  
<br>  

Групповые фреймы имеют смысл применять, когда в ```ORDER BY``` окна указан неуникальный набор столбцов. Например, ```ORDER BY department``` или ```ORDER BY city``` формирует группы строк с одинаковым значением департамента или города — в таких случаях использование группового фрейма оправданно.  

---

### RANGE BETWEEN

Определение фрейма по диапазону ```RANGE BETWEEN frame_start AND frame_end```.  
Если ROWS-фреймы работают со строками, а GROUPS — с группами строк, объединенными одинаковыми значениями, то RANGE-фреймы оперируют группами строк, попадающих в заданный диапазон. Рассмотрим пример такого окна:  
<br>

```
OVER (ORDER BY Salary RANGE BETWEEN 1000 PRECEDING AND 1000 FOLLOWING)
```
<br>  

Фрейм для записи, где значение зарплаты равно X, будет охватывать сотрудников с зарплатами в диапазоне от X-1000 до X+1000 включительно. К примеру, для Dana, с зарплатой 12 000, это будет означать сотрудников с зарплатами от 11 000 до 13 000.
<br>

```
Name   |Salary|cnt|
-------+------+---+
Jose   |  8500|  1|
Angela | 10000|  4|
Brett  | 10000|  4|
Joshua | 10500|  4|
Andrew | 11000|  5|  -- frame_start
Dana   | 12000|  3|  -- current row
Daniel | 12500|  2|  -- frame_end
Tammy  | 14000|  7|
Brandy | 14000|  7|
Sean   | 14500|  7|
Melanie| 14500|  7|
James  | 14500|  7|
Michael| 14500|  7|
April  | 14500|  7|
Shawn  | 17000|  1|
```
<br>  

Для наглядности рассчитаем фрейм для каждой записи:
```
Name   |Salary|cnt|
-------+------+---+
Jose   |  8500|  1|  <= 7500 - 9500 Jose
Angela | 10000|  4|  <= 9000 - 11000 Angela, Brett, Joshua, Andrew 
Brett  | 10000|  4|  <= 9000 - 11000 Angela, Brett, Joshua, Andrew 
Joshua | 10500|  4|  <= 9000 - 11000 Angela, Brett, Joshua, Andrew 
Andrew | 11000|  5|  <= 10000 - 12000 Angela, Brett, Joshua, Andrew, Dana
Dana   | 12000|  3|  <= 11000 - 13000 Andrew, Dana, Daniel
Daniel | 12500|  2|  <= 11500 - 13500 Dana, Daniel
Tammy  | 14000|  7|  <= 13000 - 15000 Tammy, Brandy, Sean, Milaniel, James, Michael, April
Brandy | 14000|  7|  <= 13000 - 15000 Tammy, Brandy, Sean, Milaniel, James, Michael, April
Sean   | 14500|  7|  <= 13500 - 15500 Tammy, Brandy, Sean, Milaniel, James, Michael, April
Melanie| 14500|  7|  <= 13500 - 15500 Tammy, Brandy, Sean, Milaniel, James, Michael, April
James  | 14500|  7|  <= 13500 - 15500 Tammy, Brandy, Sean, Milaniel, James, Michael, April
Michael| 14500|  7|  <= 13500 - 15500 Tammy, Brandy, Sean, Milaniel, James, Michael, April
April  | 14500|  7|  <= 13500 - 15500 Tammy, Brandy, Sean, Milaniel, James, Michael, April
Shawn  | 17000|  1|  <= 16000 - 18000 Shawn
```
<br>  

У RANGE-фреймов несколько особенностей:   
* Только один столбец в ```order by```  

Поскольку range-фрейм динамически рассчитывается по вхождению в диапазон ```between .. and ..```, то в ```ORDER BY``` должен быть ровно один столбец;  

* Только числа или даты для N ```preceding``` / ```following```  

Условия N ```PRECEDING``` и N ```FOLLOWING``` применимы исключительно к числовым столбцам и столбцам с датами. Однако, разные СУБД используют свой собственный синтаксис для работы с датами в диапазонных фреймах. Например:  
	- **PostgreSQL** используется следующий формат: ```RANGE BETWEEN INTERVAL '1 day' PRECEDING AND INTERVAL '10 days' FOLLOWING```;  
	- **MySQL** синтаксис выглядит так: ```RANGE BETWEEN INTERVAL 1 DAY PRECEDING AND INTERVAL 10 DAY FOLLOWING```.  

* Current row — аналогично groups-фрейму

Условие ```current row``` для range-фрейма функционирует так же, как и для groups-фрейма — оно включает строки с одинаковыми значениями в столбце, указанном в ```ORDER BY```. Условия ```unbounded preceding``` и ```unbounded following``` работают одинаково для всех типов фреймов: они охватывают строки от начала секции (```unbounded preceding```) и до конца секции (```unbounded following```). 

---
<br>  

## EXCLUDE

Теперь мы знаем, что фрейм выглядит так:  
```{ ROWS | GROUPS | RANGE } BETWEEN frame_start AND frame_end```. Но как быть если нам нужно исключить часть фрейма из результирующего набора?  
<br>  

Представим, что хотим узнать как изменится средняя заработная плата если уволить конкретного сотрудника. Для начала посчитаем среднюю з/п.  
<br>  

```
Name   |Salary|avg_salary|
-------+------+----------+
Shawn  | 17000|   12800.0|
Sean   | 14500|   12800.0|
Melanie| 14500|   12800.0|
James  | 14500|   12800.0|
Michael| 14500|   12800.0|
April  | 14500|   12800.0|
Tammy  | 14000|   12800.0|
Brandy | 14000|   12800.0|
Daniel | 12500|   12800.0|
Dana   | 12000|   12800.0|
Andrew | 11000|   12800.0|
Joshua | 10500|   12800.0|
Angela | 10000|   12800.0|
Brett  | 10000|   12800.0|
Jose   |  8500|   12800.0|

SELECT Name,	   
       Salary,
       AVG (Salary) OVER () AS avg_salary
  FROM employee_v
 ORDER BY Salary DESC;

```
<br>  

Для этого нам понадобится явно задать фрейм, используем уже знакомую нам конструкцию ```OVER (ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)```.  
Добавим условие для исключения текущий строки ```OVER (ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING EXCLUDE CURRENT ROW)``` и посмотрим как изменится средняя заработная плата если удалить конкретного сотрудника из списка.  
<br>  

```
Name   |Salary|avg_salary|avg_salary_without|diff  |
-------+------+----------+------------------+------+
Shawn  | 17000|   12800.0|           12500.0| 300.0|
Sean   | 14500|   12800.0|           12678.6| 121.0|
Melanie| 14500|   12800.0|           12678.6| 121.0|
James  | 14500|   12800.0|           12678.6| 121.0|
Michael| 14500|   12800.0|           12678.6| 121.0|
April  | 14500|   12800.0|           12678.6| 121.0|
Tammy  | 14000|   12800.0|           12714.3|  86.0|
Brandy | 14000|   12800.0|           12714.3|  86.0|
Daniel | 12500|   12800.0|           12821.4| -21.0|
Dana   | 12000|   12800.0|           12857.1| -57.0|
Andrew | 11000|   12800.0|           12928.6|-129.0|
Joshua | 10500|   12800.0|           12964.3|-164.0|
Angela | 10000|   12800.0|           13000.0|-200.0|
Brett  | 10000|   12800.0|           13000.0|-200.0|
Jose   |  8500|   12800.0|           13107.1|-307.0|

  WITH cte AS (
SELECT Name,	   
       Salary,
       AVG (Salary) OVER (ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS avg_salary,
       ROUND(AVG (Salary) OVER (ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING EXCLUDE CURRENT ROW),1) AS avg_salary_without	   
  FROM "duckdb test".main.employee_v
 ORDER BY Salary DESC)
 
SELECT Name,
       Salary,
       avg_salary,
       avg_salary_without,
       ROUND(avg_salary - avg_salary_without) AS diff
  FROM cte
```
---
<br>

### Разновидности EXCLUDE
<br>  

Существует 4 вида EXCLUDE. Рассмотрим различные варианты исключения записей из фреймов:  
* ```EXCLUDE NO OTHERS``` - это вариант по умолчанию, когда ничего не исключается. Если явно не указать условие исключения, будет применен именно этот режим.  
* ```EXCLUDE CURRENT ROW``` - в этом случае из фрейма исключается текущая запись, как мы делали на предыдущем шаге для конкретного сотрудника.  
* ```EXCLUDE GROUP``` - при использовании данного условия из фрейма исключается текущая запись, а также все записи, равные ей по значениям столбцов, указанных в ```ORDER BY```.  
* ```EXCLUDE TIES``` - позволяет оставить текущую запись в фрейме, но исключить из него все записи, равные текущей по значениям в столбцах ```ORDER BY```.
<br>

Рассмотрим как каждый из них работает на примере **Tammy**.  
<br>  

**EXCLUDE NO OTHERS**
```
Это вариант по умолчанию, когда ничего не исключается.
Если явно не указать условие исключения, будет применен именно этот режим.

Name   |Salary|avg    |
-------+------+-------+
Jose   |  8500|12800.0|
Angela | 10000|12800.0|
Brett  | 10000|12800.0|
Joshua | 10500|12800.0|
Andrew | 11000|12800.0|
Dana   | 12000|12800.0|
Daniel | 12500|12800.0|
Tammy  | 14000|12800.0| <=
Brandy | 14000|12800.0|
Sean   | 14500|12800.0|
Melanie| 14500|12800.0|
James  | 14500|12800.0|
Michael| 14500|12800.0|
April  | 14500|12800.0|
Shawn  | 17000|12800.0|

SELECT Name,	   
       Salary,
       AVG (Salary) OVER (ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING EXCLUDE NO OTHERS) AS avg
  FROM employee_v
 ORDER BY Salary 

```
<br>  

**EXCLUDE CURRENT ROW**
```
В этом случае из фрейма исключается текущая запись, как мы делали на предыдущем шаге для конкретного сотрудника.

Name   |Salary|avg    |
-------+------+-------+
Jose   |  8500|13107.1|
Angela | 10000|13000.0|
Brett  | 10000|13000.0|
Joshua | 10500|12964.3|
Andrew | 11000|12928.6|
Dana   | 12000|12857.1|
Daniel | 12500|12821.4|
-----------------------
Tammy  | 14000|12714.3| <= исключаем текущую строку, смотрим на то как меняется среднее без этой записи
-----------------------
Brandy | 14000|12714.3|
Sean   | 14500|12678.6|
Melanie| 14500|12678.6|
James  | 14500|12678.6|
Michael| 14500|12678.6|
April  | 14500|12678.6|
Shawn  | 17000|12500.0|

SELECT Name,	   
       Salary,
       ROUND(AVG (Salary) OVER (ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING EXCLUDE CURRENT ROW),1) AS avg
  FROM employee_v
 ORDER BY Salary 

```
<br>  

**EXCLUDE GROUP**
```
При использовании данного условия из фрейма исключается текущая запись, а также все записи,
равные ей по значениям столбцов, указанных в ORDER BY.

Name   |Salary|avg    |
-------+------+-------+
Jose   |  8500|13107.1|
Angela | 10000|13230.8|
Brett  | 10000|13230.8|
Joshua | 10500|12964.3|
Andrew | 11000|12928.6|
Dana   | 12000|12857.1|
Daniel | 12500|12821.4|
-----------------------
Brandy | 14000|12615.4| <= Brandy == Tammy по Salary, значит тоже исключаем
Tammy  | 14000|12615.4| <= Tammy и равные ей записи по Salary исключаются. 164 000 / 13 = 12 615
-----------------------
Melanie| 14500|11950.0|
James  | 14500|11950.0|
Michael| 14500|11950.0|
April  | 14500|11950.0|
Sean   | 14500|11950.0|
Shawn  | 17000|12500.0|

SELECT Name,	   
       Salary,
       ROUND(AVG (Salary) OVER (ORDER BY salary ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING EXCLUDE GROUP),1) AS avg
  FROM employee_v
 ORDER BY Salary 

```
<br>  

**EXCLUDE TIES**
```
Позволяет оставить текущую запись в фрейме, но исключить из него все записи,
равные текущей по значениям в столбцах ORDER BY.

Name   |Salary|avg    |
-------+------+-------+
Jose   |  8500|12800.0|
Angela | 10000|13000.0|
Brett  | 10000|13000.0|
Joshua | 10500|12800.0|
Andrew | 11000|12800.0|
Dana   | 12000|12800.0|
Daniel | 12500|12800.0|
-----------------------
Brandy | 14000|12714.3| <= Brandy == Tammy по Salary, значит исключаем
Tammy  | 14000|12714.3| <= Tammy оставляем, а равные ей исключаем. 178 000 / 14 = 12 714
-----------------------
Sean   | 14500|12181.8|
Melanie| 14500|12181.8|
James  | 14500|12181.8|
Michael| 14500|12181.8|
April  | 14500|12181.8|
Shawn  | 17000|12800.0|

SELECT Name,	   
       Salary,
       ROUND(AVG (Salary) OVER (ORDER BY salary ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING EXCLUDE TIES),1) AS avg
  FROM employee_v
 ORDER BY Salary

```
---
<br>

## FILTER
<br>  

Продолжим работать с таблицей зарплат сотрудников. Давайте посмотрим на то как изменится средняя зарплата если не учитывать зарплаты WEB-разработчиков. Мы могли бы переписать запрос с условием ```WHERE "Job Title" <> 'Web Developer'```, но есть способ проще. Используем ```FILTER``` в оконной функции.  

**Запрос**
```
SELECT Name,	
       "Job Title",
       Salary,
       AVG (Salary) OVER () AS avg_salary, 							<= базовое значение средней зп по всем сотрудникам
       AVG (SALARY) FILTER ("Job Title" <> 'Web Developer') OVER () AS avg_salary_withou_WD	<= средняя зп если не принимать в расчет зп Web-Developer
  FROM employee_v
 ORDER BY "Job Title", Salary Desc
```
<br>  

**Результат**
```
Name   |Job Title      |Salary|avg_salary|avg_salary_withou_WD|
-------+---------------+------+----------+--------------------+
Tammy  |HR Manager     | 14000|   12800.0|             12000.0|
Daniel |HR Manager     | 12500|   12800.0|             12000.0|
Andrew |HR Manager     | 11000|   12800.0|             12000.0|
Angela |HR Manager     | 10000|   12800.0|             12000.0|
Brett  |HR Manager     | 10000|   12800.0|             12000.0|
-------+---------------+------+----------+--------------------+
Shawn  |Project Manager| 17000|   12800.0|             12000.0|
Sean   |Project Manager| 14500|   12800.0|             12000.0|
Dana   |Project Manager| 12000|   12800.0|             12000.0|
Joshua |Project Manager| 10500|   12800.0|             12000.0|
Jose   |Project Manager|  8500|   12800.0|             12000.0|
-------+---------------+------+----------+--------------------+
Melanie|Web Developer  | 14500|   12800.0|             12000.0|
James  |Web Developer  | 14500|   12800.0|             12000.0|
Michael|Web Developer  | 14500|   12800.0|             12000.0|
April  |Web Developer  | 14500|   12800.0|             12000.0|
Brandy |Web Developer  | 14000|   12800.0|             12000.0|
```
---
<br>

## CASE
<br>  

Посмотрим как изменится фонд оплаты труда если каждому отделу проведем повышение, например, HR поработали хорошо и получат прибавку в 10%, Project получат 5% сверху а вот Web-Developer получат меньше всех, всего 1.5%. Звучит хорошо, но как это отобразить в итоговой выборке? Писать 3 разных запроса? Нет, все проще, используем ```CASE WHEN``` вместо ```FILTER``` в оконной функции.   

**Результат**
```
Name   |Job Title      |Salary|basic_sum_of_salary|new_sum_of_salary|
-------+---------------+------+-------------------+-----------------+
Tammy  |HR Manager     | 14000|              57500|            63250|
Daniel |HR Manager     | 12500|              57500|            63250|
Andrew |HR Manager     | 11000|              57500|            63250|
Angela |HR Manager     | 10000|              57500|            63250|
Brett  |HR Manager     | 10000|              57500|            63250|
-------+---------------+------+-------------------+------------------
Shawn  |Project Manager| 17000|              62500|            65625|
Sean   |Project Manager| 14500|              62500|            65625|
Dana   |Project Manager| 12000|              62500|            65625|
Joshua |Project Manager| 10500|              62500|            65625|
Jose   |Project Manager|  8500|              62500|            65625|
-------+---------------+------+-------------------+------------------
Melanie|Web Developer  | 14500|              72000|            73080|
James  |Web Developer  | 14500|              72000|            73080|
Michael|Web Developer  | 14500|              72000|            73080|
April  |Web Developer  | 14500|              72000|            73080|
Brandy |Web Developer  | 14000|              72000|            73080|
```
<br>  

**Запрос**
```
SELECT Name,	
       "Job Title",
       Salary,
       SUM (Salary) OVER (PARTITION BY "Job Title" ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS basic_sum_of_salary,
       ROUND (SUM (CASE 
                        WHEN "Job Title" = 'HR Manager' THEN Salary * 1.1
                        WHEN "Job Title" = 'Project Manager' THEN Salary * 1.05
                        WHEN "Job Title" = 'Web Developer' THEN Salary * 1.015
                   END) OVER (PARTITION BY "Job Title" ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)) AS new_sum_of_salary
  FROM employee_v
 ORDER BY "Job Title", Salary DESC;
```
