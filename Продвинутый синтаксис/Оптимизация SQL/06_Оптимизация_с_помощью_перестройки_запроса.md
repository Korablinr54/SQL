# Оптимизация с помощью перестройки запроса

Одна из причин медленной работы БД - неоптимальные запросы.  

## Оптимизация трафика 

### количество полей
Самый очевидный способ оптимизации. Чтобы сократить время выполнения запроса нужно уменьшить количество передаваемой информации.  

Например, нужно вывести номер и дату заказа.  
```sql
SELECT * 
  FROM orders 
 WHERE 1 = 1
   AND customer_id = ? 
-- ? означает переменное значение, подставляемое в запрос
```
Запрос решает задачу но есть проблема, в выоде присуствует слишком много лишних полей. К тому же хорошей практикой является явное перечисление колонок даже если нужны все.

```sql
SELECT id, date 
  FROM orders 
 WHERE 1 = 1 
   AND customer_id = ?
-- вернет только те данные, которые необходимы
```

### количество строк
Например, нам нужно определить факт наличия заказов у покупателя, если есть хотя бы один заказ.
```sql
SELECT id 
  FROM orders 
 WHERE 1 = 1
   AND customer_id = ?;
```
Запрос решает проблему, но возвращает избыточное количество данных. Нам нужно просто понимать, есть ли у клиента хотя бы один заказ, а не видеть все его заказы.

```sql
SELECT id 
  FROM orders 
 WHERE 1 = 1 
   AND user_id = ?
 LIMIT 1;
```
Ограничим выборку одной строкой, нас это вполне устроит и никаких лишних данных.

### вычисления на стороне базы

Необходим объект для расчета количества заказов и их средней стоимости.
```sql
SELECT category, 
       amount, 
       price 
  FROM orders o
  JOIN products p ON o.product_id = p.id
 WHERE 1 = 1
   AND o.created_at BETWEEN first_of_month AND last_of_month;
```

Как и ранее запрос выполняет возложенные на него условия, но это буквально передача тысяч строк. А можно расчитать все на стороне БД и передавать уже готовый результат.

```sql
SELECT category,
       COUNT(*) as orders_count, 
       AVG(amount * price) as average_sum
  FROM orders o
  JOIN products p ON o.product_id = p.id
 WHERE 1 = 1
   AND  o.created_at BETWEEN first_of_month AND last_of_month
 GROUP BY category;
```

## Оптимизация вычислений

### преобразование типов в условии

Предположим, что необходимо выбрать данные за прошедший месяц.
```sql
SELECT COUNT(*) 
  FROM orders
 WHERE 1 = 1
   AND EXTRACT(YEAR FROM created_at) = 2021 
   AND EXTRACT(MONTH FROM created_at) = 5;
```
Запрос конечно отрабатывает как положено, но что здесь можно улучшить с точки зрения оптимизации? Мы видим тут двойное преобразование типов данных. Сначала получаем год, затем месяц. Это можно сделать один раз тем самым сократив время выполнения запроса.

```sql
SELECT COUNT(*) 
  FROM orders
 WHERE 1 = 1
   AND to_char(created_at, 'YYYYMM') = '202105';
```

Несмотря на то, что мы избавились от двойного изменения типов данных такой подход может не дать особенного эффекта. Дело в том, что сначала мы сравниали числа, а сейчас сравниваем строки. Числа сранивать быстрее. Да и в целом `to_char` может работать медленее `EXTRACT` Нужно придумать что-то еще.

```sql
SELECT COUNT(*) 
  FROM orders  
 WHERE 1 = 1
   AND created_at BETWEEN '2021-05-01 00:00:00' AND '2021-05-31 23:59:59';
```
Что если нам вообще избавиться от преобразований типа данных? Это существенно сэкономило время!

### оптимизация сравнения IN

Например, ORM может формировать запрос следующего вида:
```sql
SELECT id, 
       name, 
       address, 
       phone, 
       email
  FROM customers
WHERE 1 = 1
  AND status_id IN (1, 3, 4, 56, 78 .....); -- сотни значений 
```
Проблема: status_id построчно сравнивает сравнивает значение с каждым status_id.

```sql
SELECT id, 
       name, 
       address, 
       phone, 
       email
  FROM customers
 INNER JOIN (VALUES (1), (3), (4) ...) AS statuses (id) 
    ON customers.status_id = statuses.id;
```
Можно использовать виртуальную таблицу и join, чтобы отсечь все лишние строки, это будет быстрее.

## Оптимизация чтения данных
