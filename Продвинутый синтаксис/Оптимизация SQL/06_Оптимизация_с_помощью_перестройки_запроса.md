# Оптимизация с помощью перестройки запроса

Одна из причин медленной работы БД - неоптимальные запросы.  

## Оптимизация трафика 

### количество полей
Самый очевидный способ оптимизации. Чтобы сократить время выполнения запроса нужно уменьшить количество передаваемой информации.  

Например, нужно вывести номер и дату заказа.  
```sql
SELECT * 
  FROM orders 
 WHERE 1 = 1
   AND customer_id = ? 
-- ? означает переменное значение, подставляемое в запрос
```
Запрос решает задачу но есть проблема, в выоде присуствует слишком много лишних полей. К тому же хорошей практикой является явное перечисление колонок даже если нужны все.

```sql
SELECT id, date 
  FROM orders 
 WHERE 1 = 1 
   AND customer_id = ?
-- вернет только те данные, которые необходимы
```

### количество строк
Например, нам нужно определить факт наличия заказов у покупателя, если есть хотя бы один заказ.
```sql
SELECT id 
  FROM orders 
 WHERE 1 = 1
   AND customer_id = ?;
```
Запрос решает проблему, но возвращает избыточное количество данных. Нам нужно просто понимать, есть ли у клиента хотя бы один заказ, а не видеть все его заказы.

```sql
SELECT id 
  FROM orders 
 WHERE 1 = 1 
   AND user_id = ?
 LIMIT 1;
```
Ограничим выборку одной строкой, нас это вполне устроит и никаких лишних данных.

### вычисления на стороне базы

Необходим объект для расчета количества заказов и их средней стоимости.
```sql
SELECT category, 
       amount, 
       price 
  FROM orders o
  JOIN products p ON o.product_id = p.id
 WHERE 1 = 1
   AND o.created_at BETWEEN first_of_month AND last_of_month;
```

Как и ранее запрос выполняет возложенные на него условия, но это буквально передача тысяч строк. А можно расчитать все на стороне БД и передавать уже готовый результат.

```sql
SELECT category,
       COUNT(*) as orders_count, 
       AVG(amount * price) as average_sum
  FROM orders o
  JOIN products p ON o.product_id = p.id
 WHERE 1 = 1
   AND  o.created_at BETWEEN first_of_month AND last_of_month
 GROUP BY category;
```

## Оптимизация вычислений

### преобразование типов в условии

Предположим, что необходимо выбрать данные за прошедший месяц.
```sql
SELECT COUNT(*) 
  FROM orders
 WHERE 1 = 1
   AND EXTRACT(YEAR FROM created_at) = 2021 
   AND EXTRACT(MONTH FROM created_at) = 5;
```
Запрос конечно отрабатывает как положено, но что здесь можно улучшить с точки зрения оптимизации? Мы видим тут двойное преобразование типов данных. Сначала получаем год, затем месяц. Это можно сделать один раз тем самым сократив время выполнения запроса.

```sql
SELECT COUNT(*) 
  FROM orders
 WHERE 1 = 1
   AND to_char(created_at, 'YYYYMM') = '202105';
```

Несмотря на то, что мы избавились от двойного изменения типов данных такой подход может не дать особенного эффекта. Дело в том, что сначала мы сравниали числа, а сейчас сравниваем строки. Числа сранивать быстрее. Да и в целом `to_char` может работать медленее `EXTRACT` Нужно придумать что-то еще.

```sql
SELECT COUNT(*) 
  FROM orders  
 WHERE 1 = 1
   AND created_at BETWEEN '2021-05-01 00:00:00' AND '2021-05-31 23:59:59';
```
Что если нам вообще избавиться от преобразований типа данных? Это существенно сэкономило время!

### оптимизация сравнения IN

Например, ORM может формировать запрос следующего вида:
```sql
SELECT id, 
       name, 
       address, 
       phone, 
       email
  FROM customers
WHERE 1 = 1
  AND status_id IN (1, 3, 4, 56, 78 .....); -- сотни значений 
```
Проблема: status_id построчно сравнивает сравнивает значение с каждым status_id.

```sql
SELECT id, 
       name, 
       address, 
       phone, 
       email
  FROM customers
 INNER JOIN (VALUES (1), (3), (4) ...) AS statuses (id) 
    ON customers.status_id = statuses.id;
```
Можно использовать виртуальную таблицу и join, чтобы отсечь все лишние строки, это будет быстрее.

## Оптимизация чтения данных

Чем меньше серверу приходится считывать данных тем быстрее он это сделает.  

### оптимизация при помощи JOIN

Нужно найти заказы, количество товара в которых в два и более раза превышает среднее количество для данного товара.  
```sql
SELECT id, 
       product_id, 
       amount
  FROM orders o
 WHERE 1 = 1
   AND o.amount > 2 * (SELECT AVG(amount) 
                         FROM orders 
                        WHERE o.product_id = orders.product_id);
```

Проблема: многократное считывание данных. В запросе есть кореллирующий запрос, т.е. подзапрос выполняется для каждой строки основного запроса. В данном случае лукчше использоватб `JOIN`.  

```sql
SELECT id, 
       amount, 
       o.product_id, 
       avg2
  FROM orders o
 INNER JOIN (SELECT product_id, 
                    AVG(amount) * 2 AS avg2 
               FROM orders
              GROUP BY product_id) avg_orders ON o.product_id = avg_orders.product_id AND o.amount > avg2;
```
Так расчет выполнится всего один раз, а `INNER JOIN` отфильтрует результат по условию.

Это классический пример почему джины предпочтительнее подзапросов.

### оптимизация при помощи EXISTS

Выбрать товары, которые заказали в определенный период.
```sql
SELECT DISTINCT p.id, 
       p.name
  FROM products p
  JOIN orders o ON p.id = o.product_id
 WHERE 1 = 1
   AND o.created_at BETWEEN '2023-10-01 00:00:00' AND '2023-10-31 23:59:59';
```

Запрос сначала объединит проекты по условию, затем выберет данные из указанног опромежутка. Что тут хорошо? Уже применен принцип экономии трафика, нет лишних столбцов. А также не используется преобразование типов, что также сокращет время выполнения. Что можем улучшить?  
Подумаем вот над чем, в задаче нужны не заказы а лишь уникальные товары, разработчик использовал `DISTINCT`, что весьма трудоемко. Ведь если взглянуть на логику соединения то можно предположить, что отношения между таблицами один ко многим, один заказ может содержать множество товаров. 

В данном случае выигрышнее будет использование EXISTS, который останавит поиск как только для товара в products будет найдена пара в таблице orders.

```sql
SELECT p.id, 
       p.name
  FROM products p
 WHERE EXISTS (
    -- проверим, есть ли записи о заказах продукта p 
    -- за период между '2023-10-01 00:00:00' и '2023-10-31 23:59:59'
    -- так как нам не важны данные заказа, а лишь его наличие 
    -- то будем возвращать булево значение true в качестве результата
    SELECT true 
      FROM orders o
     WHERE p.id = o.product_id AND o.created_at BETWEEN '2023-10-01 00:00:00' AND '2023-10-31 23:59:59');
```

### оптимизация при помощи фильтрации и сортировки

Найдем дату последнего заказа определенного покупателя.
```sql
SELECT MAX(created_at) 
  FROM orders 
 GROUP BY customer_id  
HAVING customer_id = 4;
```

Запрос читает всю таблицу группируя строки по полю идентификатора пользователя. Лучше отказаться от агрегации в пользу оператора `LIMIT` и сортировки. Это отработает быстрее.

```sql
SELECT id, 
       created_at 
  FROM orders 
 WHERE 1 = 1
   AND customer_id = 4
 ORDER BY created_at DESC 
 LIMIT 1;
```

### пагинация

Пагинация — это разбиение большого набора данных на отдельные страницы. Она необходима для отображения информации порциями (например, по 30 записей), что снижает нагрузку на сервер и повышает скорость отклика интерфейса.  

**Базовый подход с OFFSET**
Стандартный метод использует `LIMIT` и `OFFSET` в SQL-запросе:

```sql
SELECT * 
  FROM таблица 
 ORDER BY поле 
 LIMIT 30 
OFFSET 30;
```
Однако при больших значениях `OFFSET` (тысячи и миллионы строк) производительность резко падает. База данных вынуждена читать и сортировать все пропускаемые строки, даже если возвращает всего несколько записей.

Проблема производительности  
На примере таблицы с 10 млн записей:  

OFFSET 30 → ~1 мс

OFFSET 3 000 000 → >500 мс

OFFSET 9 000 000 → >2 с

**Оптимизированный метод**
Вместо `OFFSET` используйте фильтрацию по ключевому полю:  

Сначала найдите начальный идентификатор страницы:  
```sql
SELECT id 
  FROM таблица 
 ORDER BY id 
 LIMIT 1 
OFFSET 3000000;
```

Затем получите данные, начиная с этого ID:
```sql
SELECT * 
  FROM таблица 
 WHERE id >= (полученный_id) 
 ORDER BY id 
 LIMIT 30;
```

Это сокращает время выполнения с секунд до миллисекунд, так как используется индекс первичного ключа.

Ключевые принципы:  
* Всегда применяйте пагинацию вместе с сортировкой  
* Для больших таблиц избегайте глубокого OFFSET  
* Используйте фильтрацию по индексированным полям  
* Метод с WHERE id >= эффективен при последовательной навигации  

**Вывод**  
Пагинация через `OFFSET` подходит для небольших наборов данных. Для работы с миллионами записей переходите на ключевой метод фильтрации — это обеспечит стабильную производительность независимо от номера страницы.

## CTE

CTE расчитывается один раз и хранит результат вычисления до конца выполнения запроса, поэтому можно использовать как с целью экономии вычислительных ресурсов так и с целью снижения объема чтения данных.

Общий принцип - если в запросе есть повторяющиеся подзапросы, вынесите их в СТЕ.

Запрос об отмененных заказах, который мы использовали ранее:
```sql
SELECT id, 
       amount, 
       o.product_id, 
       avg2
  FROM orders o
 INNER JOIN (SELECT product_id, 
                    AVG(amount) * 2 AS avg2 
               FROM orders
              GROUP BY product_id) avg_orders ON o.product_id = avg_orders.product_id AND o.amount > avg2;
```

В целях оптимизации используем СТЕ
```sql
  WITH avg_orders AS (
SELECT product_id, AVG(amount) * 2 AS avg2 
  FROM orders 
 GROUP BY product_id) 

SELECT id, 
       amount, 
       o.product_id, 
       avg2
  FROM orders o 
 INNER JOIN avg_orders ON o.product_id = avg_orders.product_id 
                       AND o.amount > avg2;
```

Суть оптимизации в данном случае в том, что дорогая операция по подсчету среднего выполняется один раз, затем лишь объединяется через `JOIN`.