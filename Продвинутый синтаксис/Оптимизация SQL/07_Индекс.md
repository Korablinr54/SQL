# Индекс

Индексы — позволяют быстрее находить нужные данные, без необходимости просматривать всю таблицу. Обычно индексы формируются для столбцов, которые используются в `where` или `join`. При создании первичного ключа или ограничения `unique` индекс генерируется автоматически. Индексы в целом наиболее эффективны для столбцов с большим количеством разных значений. Меньше повторов значений - эффективнее работал индекса. И, да, на маленьких таблицах в нем особо нет смысла. 

Разберемся, что делает структуру данных индексом. Индекс определяется по трем ключевым признакам:  

* Дублирующая информация: Это вспомогательная структура, которую можно полностью удалить без ущерба для целостности данных, так как вся исходная информация хранится в основной таблице.  

* Прозрачность для логики приложения: Наличие или отсутствие индекса не влияет на результат выполнения запросов. Приложение работает с одними и теми же данными, независимо от того, используется индекс или нет.  

* Цель — оптимизация производительности: Индекс создается с расчетом на то, что он ускорит обработку определенных операций выборки, фильтрации или сортировки данных.  

Иными словами, индекс — это «невидимый» и нефункциональный (с точки зрения бизнес-логики) слой, задача которого — сделать работу с данными быстрее.  

Ускорение запросов с помощью индексов имеет свою цену. Поскольку индекс хранит копию данных, при каждом изменении таблицы он также требует обновления, что создает дополнительную нагрузку и занимает место на диске. В PostgreSQL, например, индексы могут замедлять процесс очистки базы (VACUUM).  

Однако, не стоит преувеличивать эти издержки.  

## B-деревья

**Основная идея**  
Самый популярный тип индексов в базах данных основан на алгоритме бинарного поиска и реализован в виде **B-Tree**-дерева.  

Принцип бинарного поиска  
Алгоритм работает с отсортированным массивом. Его цель — найти элемент за минимальное число шагов.  

- **Как работает**: На каждом шаге искомый элемент сравнивается с элементом в середине текущего диапазона поиска. Если искомый элемент больше — поиск продолжается в правой половине диапазона, если меньше — в левой. Процесс повторяется до нахождения элемента.  
- **Эффективность**: Количество шагов для поиска равно log₂(N), где N — число элементов. Это делает поиск чрезвычайно быстрым на больших данных. Например, для 100 миллионов элементов нужно всего около 27 шагов, в то время как линейный перебор в худшем случае потребует 100 миллионов операций.  

### Условия для бинарного поиска  

1) Данные должны быть отсортированы (по возрастанию или убыванию).  
2) Элементы должны быть сопоставимы (например, числа, даты, строки).  

### Бинарное дерево поиска (прототип B-Tree)

Это простейшая древовидная структура, наглядно демонстрирующая принцип работы индекса. В примере приведён отсортированный массив из 15 элементов.  

* **Как устроено**: В корне дерева находится средний элемент массива (например, 12). Все элементы меньше корня идут в его левое поддерево, а все большие — в правое поддерево. Этот принцип рекурсивно повторяется для каждого узла.  

* **Связь с бинарным поиском**: Каждый узел дерева — это "средний элемент" для своего подмассива. Проход от корня к листу повторяет шаги бинарного поиска. Количество уровней в сбалансированном дереве равно log₂(N).  

Бинарное дерево — это упрощённая модель. В реальных системах применяется B-Tree (сбалансированное дерево), которое оптимизировано для работы с диском.

**Как проходит поиск:**

1) Начинается с корневого узла.  
2) Внутри узла происходит быстрый поиск (часто тоже бинарный), чтобы определить, какой интервал (и, следовательно, какую ссылку) выбрать.  
3) Процесс повторяется, пока не будет найден листовой узел с искомым значением (или диапазоном).  

**Главное преимущество**: За счёт огромной "ширины" (числа ключей в узле) дерево имеет очень маленькую "глубину" (часто 3-4 уровня), даже для миллиардов записей. Поскольку каждый переход на новый уровень — это чтение с диска, малое число уровней делает поиск невероятно быстрым.

### Сбалансированные деревья

Дерево, в котором расстояния от корня до любого листа либо равны, либо отличаются не более чем на 1. Такие деревья оптимальны для поиска, так как гарантируют, что для доступа к любому элементу потребуется примерно одинаковое и минимальное количество шагов (log₂(N)). В дереве из предыдущего примера (с корнем 12) все листья находятся на одном уровне. Поиск любого числа потребует ровно 3 шага.   