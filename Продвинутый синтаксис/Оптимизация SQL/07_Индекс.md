# Индекс

Индексы — позволяют быстрее находить нужные данные, без необходимости просматривать всю таблицу. Обычно индексы формируются для столбцов, которые используются в `where` или `join`. При создании первичного ключа или ограничения `unique` индекс генерируется автоматически. Индексы в целом наиболее эффективны для столбцов с большим количеством разных значений. Меньше повторов значений - эффективнее работал индекса. И, да, на маленьких таблицах в нем особо нет смысла. 

Разберемся, что делает структуру данных индексом. Индекс определяется по трем ключевым признакам:  

* Дублирующая информация: Это вспомогательная структура, которую можно полностью удалить без ущерба для целостности данных, так как вся исходная информация хранится в основной таблице.  

* Прозрачность для логики приложения: Наличие или отсутствие индекса не влияет на результат выполнения запросов. Приложение работает с одними и теми же данными, независимо от того, используется индекс или нет.  

* Цель — оптимизация производительности: Индекс создается с расчетом на то, что он ускорит обработку определенных операций выборки, фильтрации или сортировки данных.  

Иными словами, индекс — это «невидимый» и нефункциональный (с точки зрения бизнес-логики) слой, задача которого — сделать работу с данными быстрее.  

Ускорение запросов с помощью индексов имеет свою цену. Поскольку индекс хранит копию данных, при каждом изменении таблицы он также требует обновления, что создает дополнительную нагрузку и занимает место на диске. В PostgreSQL, например, индексы могут замедлять процесс очистки базы (VACUUM).  

Однако, не стоит преувеличивать эти издержки.  

## B-деревья

**Основная идея**  
Самый популярный тип индексов в базах данных основан на алгоритме бинарного поиска и реализован в виде **B-Tree**-дерева.  

Принцип бинарного поиска  
Алгоритм работает с отсортированным массивом. Его цель — найти элемент за минимальное число шагов.  

- **Как работает**: На каждом шаге искомый элемент сравнивается с элементом в середине текущего диапазона поиска. Если искомый элемент больше — поиск продолжается в правой половине диапазона, если меньше — в левой. Процесс повторяется до нахождения элемента.  
- **Эффективность**: Количество шагов для поиска равно log₂(N), где N — число элементов. Это делает поиск чрезвычайно быстрым на больших данных. Например, для 100 миллионов элементов нужно всего около 27 шагов, в то время как линейный перебор в худшем случае потребует 100 миллионов операций.  

### Условия для бинарного поиска  

1) Данные должны быть отсортированы (по возрастанию или убыванию).  
2) Элементы должны быть сопоставимы (например, числа, даты, строки).  

### Бинарное дерево поиска (прототип B-Tree)

Это простейшая древовидная структура, наглядно демонстрирующая принцип работы индекса. В примере приведён отсортированный массив из 15 элементов.  

* **Как устроено**: В корне дерева находится средний элемент массива (например, 12). Все элементы меньше корня идут в его левое поддерево, а все большие — в правое поддерево. Этот принцип рекурсивно повторяется для каждого узла.  

* **Связь с бинарным поиском**: Каждый узел дерева — это "средний элемент" для своего подмассива. Проход от корня к листу повторяет шаги бинарного поиска. Количество уровней в сбалансированном дереве равно log₂(N).  

Бинарное дерево — это упрощённая модель. В реальных системах применяется B-Tree (сбалансированное дерево), которое оптимизировано для работы с диском.

**Как проходит поиск:**

1) Начинается с корневого узла.  
2) Внутри узла происходит быстрый поиск (часто тоже бинарный), чтобы определить, какой интервал (и, следовательно, какую ссылку) выбрать.  
3) Процесс повторяется, пока не будет найден листовой узел с искомым значением (или диапазоном).  

**Главное преимущество**: За счёт огромной "ширины" (числа ключей в узле) дерево имеет очень маленькую "глубину" (часто 3-4 уровня), даже для миллиардов записей. Поскольку каждый переход на новый уровень — это чтение с диска, малое число уровней делает поиск невероятно быстрым.

### Сбалансированные деревья

Дерево, в котором расстояния от корня до любого листа либо равны, либо отличаются не более чем на 1. Такие деревья оптимальны для поиска, так как гарантируют, что для доступа к любому элементу потребуется примерно одинаковое и минимальное количество шагов (log₂(N)). В дереве из предыдущего примера (с корнем 12) все листья находятся на одном уровне. Поиск любого числа потребует ровно 3 шага. 

Индекс B-Tree в базах данных — это не просто "бинарное дерево", а сбалансированное дерево с особым устройством узлов. Балансировка — ключевое свойство, обеспечивающее стабильно высокую скорость поиска (вставки и удаления) для любого элемента, независимо от его положения в данных. Алгоритмы B-Tree автоматически поддерживают это состояние баланса при изменениях данных.

### Индексы B-Tree

Индексы B-Tree — самый распространённый тип индексов, основанный на сбалансированных деревьях. Каждый узел дерева соответствует странице на диске (обычно 4-8 КБ), что оптимизировано для быстрого чтения. Благодаря балансировке дерево редко превышает 3-4 уровня даже для больших таблиц, обеспечивая быстрый поиск за log(N) шагов.

При изменении данных (вставка, удаление) индекс перестраивается для поддержания баланса. Простые изменения затрагивают только листья, сложные требуют ребалансировки нескольких узлов. Это ресурсоёмкий процесс, поэтому индексы ускоряют чтение, но замедляют запись.

B-Tree поддерживает работу с дубликатами и диапазонные запросы («больше/меньше») за счёт связи листьев в двусвязный список. Хотя реализации в разных СУБД отличаются, эти принципы универсальны. Для специальных задач существуют и другие типы индексов (GIN, GiST, BRIN, Hash).

# Создание и удаление индексов

Для начала выполним запрос и посмотрим на стоимость выполнения:
```sql
EXPLAIN
 SELECT *
   FROM tools_shop.users
  WHERE user_id = 98000; 
```

результат:
```
Seq Scan on users  (cost=0.00..2568.73 rows=1 width=44)
  Filter: (user_id = 98000)
```

Главным образом мы видим, что операция фильтрации выполнена посредством последовательного сканирования `Seq Scan` и ее стоимость составила `0.00` для первой строки и `2568.73` для итогового набора данных.

Теперь давайте создадим индекс и снова выполним `EXPLAIN` и взглянем на результат.  

## Создание индекса

В общем случае синтаксис выглядит так:
```sql
CREATE [UNIQUE] INDEX <имя_индекса> 
ON <имя_таблицы> (<колонка_1>, <колонка_2>, ...);
```

Если значения в колонке уникальны, то лучше использовать `UNIQUE` так индекс будет работать быстрее. В таким индексах допускается наличие `NULL` т.к. они не равны друг другу и другим значениям.

Рекомендуется использовать следующий шаблон для имени индекса:
```
<имя_таблицы>_<имя_столбца_или_столбцов>_idx
```

Давайте создадим наш первый индекс:
```sql
CREATE UNIQUE INDEX users_user_id_idx ON tools_shop.users (user_id);
```

Идентификатор пользователя должен быть уникальным, по этому мы используем здесь `UNIQUE INDEX`. После его создания он появился во вкладке Индекс внутри этой таблицы.

Выполним запрос и посмотрим на результат в планировщике:
```sql
EXPLAIN
 SELECT *
   FROM tools_shop.users
  WHERE user_id = 98000; 
```

результат:
```
Index Scan using users_user_id_idx on users  (cost=0.42..3.44 rows=1 width=44)
  Index Cond: (user_id = 98000)
```

Итак, теперь вместо `Seq Scan` (последовательное сканирование) мы видим, что операция фильтрации выполнена благодаря `Index Scan` (Индексное сканирование). А стоимость возвращения всего результата изменилась с `2568.73` на `3.44`, что лучше примерно в 300 раз!

## Составной индекс

Предположим, что в базе магазина часто осуществляется поиск покупателей по комбинации Имя + Фамиля. Выполним запрос:
```sql
EXPLAIN 
 SELECT * 
   FROM tools_shop.users 
  WHERE 1 = 1
    AND first_name = 'Arata' 
    AND last_name = 'Hopper';
```

результат:
```
Seq Scan on users  (cost=0.00..2861.67 rows=10 width=44)
  Filter: ((first_name = 'Arata'::text) AND (last_name = 'Hopper'::text))
```

Снова `Seq Scan` (последовательное сканирование), полная стоимость операции фильтрации составляет `2861.67` 

Добавим составной индекс на имя и фамилию, в этот раз без `UNIQUE` т.к. полные тезки это не такая уж редкость.
```sql
CREATE INDEX users_first_name_last_name_idx 
    ON tools_shop.users(first_name, last_name);
```

И вновь взглянем на результат выполнения запроса:
```
Bitmap Heap Scan on users  (cost=1.90..16.57 rows=10 width=44)
  Recheck Cond: ((first_name = 'Arata'::text) AND (last_name = 'Hopper'::text))
  ->  Bitmap Index Scan on users_first_name_last_name_idx  (cost=0.00..1.89 rows=10 width=0)
        Index Cond: ((first_name = 'Arata'::text) AND (last_name = 'Hopper'::text))
```
В первой строке мы видим сканирование по битовой карте `Bitmap Heap Scan`. Такой тип сканирования применяется в составном индексе.  

Стоимость запроса снизилась с `2861.67` до `16.57` - т.е. в 172 раза. Кстати условия в `where` можно писать в любом порядке, индекс все равно отработает. 

### Поведение составного индекса при поиске по части колонок

Выполним запрос фильтруя строки только по имени, или только по фамилии, в общем по одной из частей составного индекса:
```sql
EXPLAIN 
 SELECT * 
   FROM tools_shop.users 
  WHERE 1 = 1
    AND first_name = 'Arata';
```

результат:
```
Bitmap Heap Scan on users  (cost=10.08..726.21 rows=876 width=44)
  Recheck Cond: (first_name = 'Arata'::text)
  ->  Bitmap Index Scan on users_first_name_last_name_idx  (cost=0.00..9.86 rows=876 width=0)
        Index Cond: (first_name = 'Arata'::text)
```

План снова показал новые данные. Изначально стоимость выполнения была `2861.67` при последовательном сканировании и `16.57` при поиске по имени и фамилии. Сейчас при поиске по части индека, только по имени, стоимость составляет `726.21`. Это лучше чем без индекса в 4 раза.  

Выполним поиск только по фамилии:
```sql
EXPLAIN 
 SELECT * 
   FROM tools_shop.users 
  WHERE 1 = 1
    AND last_name = 'Hopper';
```

результат:
```
Bitmap Heap Scan on users  (cost=83.43..967.49 rows=1277 width=44)
  Recheck Cond: (last_name = 'Hopper'::text)
  ->  Bitmap Index Scan on users_first_name_last_name_idx  (cost=0.00..83.11 rows=1277 width=0)
        Index Cond: (last_name = 'Hopper'::text)
```
Вообще, при создании индекса важен порядок столбцов, для первого индекс еще будет работать а для последующих он не должен был работать, должно было запуститься последовательное сканирование `Seq Scan`. Но в нашем случае даже поиск по второму элементу индекса отработал с использованием сканирования по битовой карте `Bitmap Heap Scan` и стоимость все равно ниже чем без индекса вовсе. Однако лучше на это не надеятся и держать в голове, что обычно, по вторым и последующим частям составного индекса будет использоваться последовательное а не индексное сканирование.  

## Удаление индекса

Общий синтаксис:
```sql
DROP INDEX schema_name.index_name;
```

Удалим наш составной индекс:
```sql
DROP INDEX tools_shop.users_first_name_last_name_idx;
```

## Частичный или условный индекс (Partial Index)

Это индекс, который размещается не на всех строках колонки а лишь на их подмножестве. Простой пример это индекс на колонке "Статус заказа". Мы можем установить индекс на подмножестве строк, например, только для строк, статус заказа у которых равен "Завершен". Остальные строки будут перебираться последовательным сканированием.

Синтаксис:
```sql
CREATE INDEX oredrs_status_idx ON orders (status)
 WHERE status = 'Завершен'; 
```

## Другие виды индексов

### GIN (Generalized Inverted Index)

**Назначение**: Для неструктурированных данных и полнотекстового поиска.

**Идеально для**: Массивов (array), JSONB, tsvector (полнотекст), hstore. Работает по принципу «какое значение в каких строках встречается».

**Особенности**: Быстрый поиск вхождения элемента в составное значение. Медленнее на вставку/обновление, чем GiST (но компактнее). 

**Аналогия**: Индекс в конце учебника (указатель терминов с номерами страниц).

### GiST (Generalized Search Tree)

**Назначение**: Обобщённая структура для сложных типов данных и геометрии.

**Идеально для**: Геометрических типов (point, polygon), tsvector (с разными стратегиями, менее точен, чем GIN), диапазонов (range), поиска по расстоянию (<->).

**Особенност**и: Баланс между скоростью и точностью. Может возвравать ложные срабатывания (требует перепроверки). Гибкая архитектура — позволяет добавлять новые типы данных и операции.

**Аналогия**: Иерархическое разбиение пространства (как R-дерево).

### SP-GiST (Space-Partitioned GiST)

**Назначение**: Для данных, которые можно рекурсивно разбивать на непересекающиеся области.

**Идеально для**: Пространственных данных, IP-адресов (inet), текстовых строк (префиксный поиск).

**Особенности**: Эффективен, когда данные имеют естественную кластеризацию, но не подходят для сбалансированных деревьев (как B-дерево). Примеры структур разбиения: k-D дерево, префиксное дерево (trie).

**Аналогия**: Карта, последовательно разбиваемая на квадранты (как в дереве квадрантов).

### Хеш-индекс

**Назначение**: Точное совпадение (=) для простых значений.

**Идеально для**: Точного поиска по ключу, когда не нужны операции сравнения (>, <, BETWEEN).

**Особенности**: С PostgreSQL 10 стал журналируемым и устойчивым к сбоям. Меньше B-дерева, но не поддерживает уникальность, составные индексы, сортировку. Обычно проигрывает B-дереву (которое само стало очень быстрым для =).

**Аналогия**: Алфавитный указатель с прямой адресацией по хешу.