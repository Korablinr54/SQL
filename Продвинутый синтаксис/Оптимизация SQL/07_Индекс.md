# Индекс

Индексы — позволяют быстрее находить нужные данные, без необходимости просматривать всю таблицу. Обычно индексы формируются для столбцов, которые используются в `where` или `join`. При создании первичного ключа или ограничения `unique` индекс генерируется автоматически. Индексы в целом наиболее эффективны для столбцов с большим количеством разных значений. Меньше повторов значений - эффективнее работал индекса. И, да, на маленьких таблицах в нем особо нет смысла. 

Разберемся, что делает структуру данных индексом. Индекс определяется по трем ключевым признакам:  

* Дублирующая информация: Это вспомогательная структура, которую можно полностью удалить без ущерба для целостности данных, так как вся исходная информация хранится в основной таблице.  

* Прозрачность для логики приложения: Наличие или отсутствие индекса не влияет на результат выполнения запросов. Приложение работает с одними и теми же данными, независимо от того, используется индекс или нет.  

* Цель — оптимизация производительности: Индекс создается с расчетом на то, что он ускорит обработку определенных операций выборки, фильтрации или сортировки данных.  

Иными словами, индекс — это «невидимый» и нефункциональный (с точки зрения бизнес-логики) слой, задача которого — сделать работу с данными быстрее.  

Ускорение запросов с помощью индексов имеет свою цену. Поскольку индекс хранит копию данных, при каждом изменении таблицы он также требует обновления, что создает дополнительную нагрузку и занимает место на диске. В PostgreSQL, например, индексы могут замедлять процесс очистки базы (VACUUM).  

Однако, не стоит преувеличивать эти издержки.  

## B-деревья

**Основная идея**  
Самый популярный тип индексов в базах данных основан на алгоритме бинарного поиска и реализован в виде **B-Tree**-дерева.  

Принцип бинарного поиска  
Алгоритм работает с отсортированным массивом. Его цель — найти элемент за минимальное число шагов.  

- **Как работает**: На каждом шаге искомый элемент сравнивается с элементом в середине текущего диапазона поиска. Если искомый элемент больше — поиск продолжается в правой половине диапазона, если меньше — в левой. Процесс повторяется до нахождения элемента.  
- **Эффективность**: Количество шагов для поиска равно log₂(N), где N — число элементов. Это делает поиск чрезвычайно быстрым на больших данных. Например, для 100 миллионов элементов нужно всего около 27 шагов, в то время как линейный перебор в худшем случае потребует 100 миллионов операций.  

### Условия для бинарного поиска  

1) Данные должны быть отсортированы (по возрастанию или убыванию).  
2) Элементы должны быть сопоставимы (например, числа, даты, строки).  

### Бинарное дерево поиска (прототип B-Tree)

Это простейшая древовидная структура, наглядно демонстрирующая принцип работы индекса. В примере приведён отсортированный массив из 15 элементов.  

* **Как устроено**: В корне дерева находится средний элемент массива (например, 12). Все элементы меньше корня идут в его левое поддерево, а все большие — в правое поддерево. Этот принцип рекурсивно повторяется для каждого узла.  

* **Связь с бинарным поиском**: Каждый узел дерева — это "средний элемент" для своего подмассива. Проход от корня к листу повторяет шаги бинарного поиска. Количество уровней в сбалансированном дереве равно log₂(N).  

Бинарное дерево — это упрощённая модель. В реальных системах применяется B-Tree (сбалансированное дерево), которое оптимизировано для работы с диском.

**Как проходит поиск:**

1) Начинается с корневого узла.  
2) Внутри узла происходит быстрый поиск (часто тоже бинарный), чтобы определить, какой интервал (и, следовательно, какую ссылку) выбрать.  
3) Процесс повторяется, пока не будет найден листовой узел с искомым значением (или диапазоном).  

**Главное преимущество**: За счёт огромной "ширины" (числа ключей в узле) дерево имеет очень маленькую "глубину" (часто 3-4 уровня), даже для миллиардов записей. Поскольку каждый переход на новый уровень — это чтение с диска, малое число уровней делает поиск невероятно быстрым.

### Сбалансированные деревья

Дерево, в котором расстояния от корня до любого листа либо равны, либо отличаются не более чем на 1. Такие деревья оптимальны для поиска, так как гарантируют, что для доступа к любому элементу потребуется примерно одинаковое и минимальное количество шагов (log₂(N)). В дереве из предыдущего примера (с корнем 12) все листья находятся на одном уровне. Поиск любого числа потребует ровно 3 шага. 

Индекс B-Tree в базах данных — это не просто "бинарное дерево", а сбалансированное дерево с особым устройством узлов. Балансировка — ключевое свойство, обеспечивающее стабильно высокую скорость поиска (вставки и удаления) для любого элемента, независимо от его положения в данных. Алгоритмы B-Tree автоматически поддерживают это состояние баланса при изменениях данных.

### Индексы B-Tree

Индексы B-Tree — самый распространённый тип индексов, основанный на сбалансированных деревьях. Каждый узел дерева соответствует странице на диске (обычно 4-8 КБ), что оптимизировано для быстрого чтения. Благодаря балансировке дерево редко превышает 3-4 уровня даже для больших таблиц, обеспечивая быстрый поиск за log(N) шагов.

При изменении данных (вставка, удаление) индекс перестраивается для поддержания баланса. Простые изменения затрагивают только листья, сложные требуют ребалансировки нескольких узлов. Это ресурсоёмкий процесс, поэтому индексы ускоряют чтение, но замедляют запись.

B-Tree поддерживает работу с дубликатами и диапазонные запросы («больше/меньше») за счёт связи листьев в двусвязный список. Хотя реализации в разных СУБД отличаются, эти принципы универсальны. Для специальных задач существуют и другие типы индексов (GIN, GiST, BRIN, Hash).

# Создание и удаление индексов

Для начала выполним запрос и посмотрим на стоимость выполнения:
```sql
EXPLAIN
 SELECT *
   FROM tools_shop.users
  WHERE user_id = 98000; 
```

результат:
```
Seq Scan on users  (cost=0.00..2568.73 rows=1 width=44)
  Filter: (user_id = 98000)
```

Главным образом мы видим, что операция фильтрации выполнена посредством последовательного сканирования `Seq Scan` и ее стоимость составила `0.00` для первой строки и `2568.73` для итогового набора данных.

Теперь давайте создадим индекс и снова выполним `EXPLAIN` и взглянем на результат.  

## Создание индекса

В общем случае синтаксис выглядит так:
```sql
CREATE [UNIQUE] INDEX <имя_индекса> 
ON <имя_таблицы> (<колонка_1>, <колонка_2>, ...);
```

Если значения в колонке уникальны, то лучше использовать `UNIQUE` так индекс будет работать быстрее. В таким индексах допускается наличие `NULL` т.к. они не равны друг другу и другим значениям.

Рекомендуется использовать следующий шаблон для имени индекса:
```
<имя_таблицы>_<имя_столбца_или_столбцов>_idx
```

Давайте создадим наш первый индекс:
```sql
CREATE UNIQUE INDEX users_user_id_idx ON tools_shop.users (user_id);
```

Идентификатор пользователя должен быть уникальным, по этому мы используем здесь `UNIQUE INDEX`. После его создания он появился во вкладке Индекс внутри этой таблицы.

