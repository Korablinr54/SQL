# Планировщик запросов

**Планировщик запросов** (оптимизатор) в PostgreSQL — это компонент, который анализирует SQL-запросы и генерирует наиболее эффективный план выполнения. Задача планировщика — выбрать план, который, как ожидается, будет выполняться быстрее всего.  

Чтобы получить результаты запроса, PostgreSQL выполняет следующие
шаги:  
-  компилирует и преобразует инструкцию SQL в выражение, состоящее
из логических операций высокого уровня, называемое логический план;  
- оптимизирует логический план и превращает его в план выполнения;  
- выполняет (интерпретирует) план и возвращает результаты.  

## Поэтапный алгоритм работы планировщика

1) Анализ запроса  
Планировщик проверяет синтаксис и ссылки на объекты в базе

2) Планирование запроса: 
    - поиск подходящего плана в кэше - первым делом планировщик проверяет нет ли уже скомпелированного плана в кэше   
    - поиск оптимального запроса - если плана нет к кэше нет или структура базы была изменена, планировщик искать потимальный план запроса. Составит разные и выберет оптимальный  

## EXPLAIN  

Увидеть план запроса можно с помощью `EXPLAIN`  
```sql
EXPLAIN 
 SELECT * 
   FROM online_store.orders;
```
Результат выполнения:
```
QUERY PLAN
Seq Scan on orders  (cost=0.00..346.67 rows=21167 width=18)
(1 row)
```

# Сборщик статистики в PostgreSQL

Подсистема для сбора и отбражения информации о работе БД. Планировщик использует ее для того, чтобы оценить скорость выполнения запроса, объем данных, количество строк возвращаемых запросом.  
Например, в таблице было 1_000 записей, статистика давно не собиралась, таблица увеличилась до 1_000_000 записей. Без обновленной статистики Планировщик не зная об изменениях может подобрать неоптимальынй план выполнения запроса.  
Сборщик статистики отслеживает, например, общее число строк в каждой таблице или индексе, размеры таблиц или индексов, наиболее часто встречающиеся значения в каждом столбце и ещё множество параметров.  

## Запуск сбора статистики

Анализировать всю БД:
```sql
ANALYZE;
```

Анализ конкретных таблиц:
```sql
ANALYZE orders, clients, items;
```

Анализ конкретных полей таблицы:
```
ANALYZE orders (order_id, created_at);
```

# Оценка стоимости запроса

**Стоимость запроса** - это абстрактная величина, служащая для сравнения сравнения запросов планировщиком между собой.  

Рассмотрим пример:  
```sql
EXPLAIN 
 SELECT * 
   FROM online_store.orders;
```
Результат выполнения:
```
QUERY PLAN
Seq Scan on orders  (cost=0.00..346.67 rows=21167 width=18)
(1 row)
```
## cost
У стоимости `cost` в результате выполнения команды `EXPLAIN` указано два значения: `cost=0.00..346.67`.
- первое значение - "Стартовая стоимость", т.е. сколько потребуется времени для получения первой строки. У нас это `0.00` секунд.  
- второе значение - "Полная стоимость", зависит от количества возвращаемых данных. В нашем примере - `346.67`.  

Рассмотрим другой пример:
```sql
EXPLAIN 
 SELECT p.user_id, o.*
   FROM online_store.profiles p
   LEFT JOIN online_store.orders o ON o.user_id = p.user_id
  WHERE region = 'Russian Federation';
```
Результат выполнения:
```
QUERY PLAN
Hash Right Join  (cost=3584.61..4043.46 rows=21904 width=26)
Hash Cond: (o.user_id = p.user_id)
->  Seq Scan on orders o  (cost=0.00..346.67 rows=21167 width=18)
->  Hash  (cost=3310.81..3310.81 rows=21904 width=8)
        ->  Seq Scan on profiles p  (cost=0.00..3310.81 rows=21904 width=8) 
                Filter: (region = 'Russian Federation'::text)
(6 rows)
```

Здесь стоит обратить внимание, что мы получаем разную стоимость `cost` на разных строках, которые влияют на общую.  
- стартовая стоимость - `3584.61`  
- полная стоимость - `4043.46`  

# Чтение плана выполнения запроса

Выполним запрос:
```sql
SELECT f.flight_no,
       f.actual_departure,
       count(passenger_id) AS passengers
  FROM postgres_air.flight f
  JOIN postgres_air.booking_leg bl ON bl.flight_id = f.flight_id
  JOIN postgres_air.passenger p ON p.booking_id=bl.booking_id
 WHERE 1 = 1
   AND f.departure_airport = 'JFK'
   AND f.arrival_airport = 'ORD'
   AND f.actual_departure BETWEEN '2024-08-01' AND '2024-08-15'
 GROUP BY f.flight_id, f.actual_departure;
```

План выполнения выглядит следующим образом:
```
Finalize GroupAggregate  (cost=587407.91..587428.91 rows=15 width=24)
  Group Key: f.flight_id
  ->  Gather Merge  (cost=587407.91..587428.58 rows=36 width=24)
        Workers Planned: 2
        ->  Partial GroupAggregate  (cost=586407.89..586424.40 rows=15 width=24)
              Group Key: f.flight_id
              ->  Sort  (cost=586407.89..586413.34 rows=2182 width=20)
                    Sort Key: f.flight_id
                    ->  Parallel Hash Join  (cost=240298.86..586286.88 rows=2182 width=20)
                          Hash Cond: (p.booking_id = bl.booking_id)
                          ->  Parallel Seq Scan on passenger p  (cost=0.00..312941.03 rows=8810102 width=8)
                          ->  Parallel Hash  (cost=240296.75..240296.75 rows=169 width=20)
                                ->  Parallel Hash Join  (cost=7339.04..240296.75 rows=169 width=20)
                                      Hash Cond: (bl.flight_id = f.flight_id)
                                      ->  Parallel Seq Scan on booking_leg bl  (cost=0.00..212758.17 rows=7695017 width=8)
                                      ->  Parallel Hash  (cost=7338.96..7338.96 rows=6 width=16)
                                            ->  Parallel Bitmap Heap Scan on flight f  (cost=98.95..7338.96 rows=6 width=16)
                                                  Recheck Cond: (departure_airport = 'JFK'::bpchar)
                                                  Filter: ((actual_departure >= '2024-08-01 00:00:00+07'::timestamp with time zone) AND (actual_departure <= '2024-08-15 00:00:00+07'::timestamp with time zone) AND (arrival_airport = 'ORD'::bpchar))
                                                  ->  Bitmap Index Scan on flight_departure_airport  (cost=0.00..98.94 rows=11136 width=0)
                                                        Index Cond: (departure_airport = 'JFK'::bpchar)
```
План выполнения содержит оценки стоимости, ожидаемое количество возвращаемых строк. Эти значения являются приблизительными и расчитываются на основе статистики базы. Значения стоимости включают в  себя совокупную стоимость всех предыдущих операций. Для каждой операции есть две оценки стоимости: первая показывает стоимость, необходимую для создания первой строки вывода, в то время как вторая оценивает полную стоимость получения всего результата.  

