# Ключевые аспекты анализа плана выполнения запроса (EXPLAIN) в PostgreSQL

1) **Достоверность статистики**  

Планировщик PostgreSQL полностью полагается на актуальную статистику о распределении данных и размерах таблиц для выбора оптимального плана. Первый индикатор проблемы — значительное расхождение между прогнозируемым числом строк (rows) на ранних этапах плана и реальным количеством. Регулярно проверяйте и при необходимости обновляйте статистику командами `ANALYZE`. Особое внимание — таблицам после массовых изменений (загрузка, удаление, обновление большого объема данных).  

2) **Анализ стоимости (Cost) и чтение плана**  

План читается снизу вверх, и именно в этом порядке его нужно анализировать. Каждая операция (узел) имеет оценку стоимости (cost), где первое число — стоимость запуска, второе — общая стоимость. Ваша цель: найти узлы с наибольшей стоимостью, так как они являются основными потребителями ресурсов. Общая стоимость плана — это сумма, но "узким местом" часто является одна-две дорогостоящие операции, на которых и нужно сосредоточиться.  

3) **Стратегии доступа к данным (Scans)**  

Тип сканирования таблицы фундаментально влияет на производительность:  

* `Seq Scan` (Последовательное сканирование): не является однозначно худшим методом — это оптимальный и самый быстрый способ чтения данных, когда требуется получить значительную часть таблицы (условно >20-30%). Его эффективность в низких накладных расходах на последовательный доступ к диску. Планировщик выбирает `Seq Scan`, когда его расчётная стоимость (основанная на статистике) оказывается ниже, чем стоимость `Index Scan`.  

* `Index Scan` / `Index Only Scan` / `Bitmap Index Scan`: Использование индексов. Ключевой момент — селективность запроса. Индексы эффективны для выборки небольшой, целевой части данных. `Index Only Scan` — наиболее эффективен, если индекс содержит все необходимые для запроса столбцы (покрывающий индекс).  

4) **Алгоритмы соединения таблиц (Joins)**  

Выбор алгоритма соединения — это компромисс между памятью, диском и CPU:  
* `Nested Loop`: Эффективен при соединении маленькой внешней таблицы (например, по индексу) с внутренней, когда для каждой строки внешней находится мало строк во внутренней. Может быть катастрофически медленным для больших таблиц без индексов на внутренней.  
* `Hash Join`: Быстр для соединения больших наборов данных, особенно при условии равенства (=). Требует памяти для построения хэш-таблицы по одной из сторон соединения. Не подходит для условий неравенства (>, <).  
* `Merge Join`: Эффективен для предварительно отсортированных данных или при использовании индексов, обеспечивающих порядок (например, B-tree). Часто оптимален для диапазонных условий.  

