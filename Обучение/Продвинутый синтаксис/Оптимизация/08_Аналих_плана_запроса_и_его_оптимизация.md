# Ключевые аспекты анализа плана выполнения запроса (EXPLAIN) в PostgreSQL

1) **Достоверность статистики**  

Планировщик PostgreSQL полностью полагается на актуальную статистику о распределении данных и размерах таблиц для выбора оптимального плана. Первый индикатор проблемы — значительное расхождение между прогнозируемым числом строк (rows) на ранних этапах плана и реальным количеством. Регулярно проверяйте и при необходимости обновляйте статистику командами `ANALYZE`. Особое внимание — таблицам после массовых изменений (загрузка, удаление, обновление большого объема данных).  

2) **Анализ стоимости (Cost) и чтение плана**  

План читается снизу вверх, и именно в этом порядке его нужно анализировать. Каждая операция (узел) имеет оценку стоимости (cost), где первое число — стоимость запуска, второе — общая стоимость. Ваша цель: найти узлы с наибольшей стоимостью, так как они являются основными потребителями ресурсов. Общая стоимость плана — это сумма, но "узким местом" часто является одна-две дорогостоящие операции, на которых и нужно сосредоточиться.  

3) **Стратегии доступа к данным (Scans)**  

Тип сканирования таблицы фундаментально влияет на производительность:  

* `Seq Scan` (Последовательное сканирование): не является однозначно худшим методом — это оптимальный и самый быстрый способ чтения данных, когда требуется получить значительную часть таблицы (условно >20-30%). Его эффективность в низких накладных расходах на последовательный доступ к диску. Планировщик выбирает `Seq Scan`, когда его расчётная стоимость (основанная на статистике) оказывается ниже, чем стоимость `Index Scan`.  

* `Index Scan` / `Index Only Scan` / `Bitmap Index Scan`: Использование индексов. Ключевой момент — селективность запроса. Индексы эффективны для выборки небольшой, целевой части данных. `Index Only Scan` — наиболее эффективен, если индекс содержит все необходимые для запроса столбцы (покрывающий индекс).  

4) **Алгоритмы соединения таблиц (Joins)**  

Выбор алгоритма соединения — это компромисс между памятью, диском и CPU:  
* `Nested Loop`: Эффективен при соединении маленькой внешней таблицы (например, по индексу) с внутренней, когда для каждой строки внешней находится мало строк во внутренней. Может быть катастрофически медленным для больших таблиц без индексов на внутренней.  
* `Hash Join`: Быстр для соединения больших наборов данных, особенно при условии равенства (=). Требует памяти для построения хэш-таблицы по одной из сторон соединения. Не подходит для условий неравенства (>, <).  
* `Merge Join`: Эффективен для предварительно отсортированных данных или при использовании индексов, обеспечивающих порядок (например, B-tree). Часто оптимален для диапазонных условий.  

## Шаг 1. Контроль актуальности статистики

Ключевой принцип: Планировщик PostgreSQL строит планы выполнения запросов на основе статистики о данных. Устаревшая статистика ведёт к некорректным планам и падению производительности.  

Как проверить: Используйте `EXPLAIN ANALYZE` — сравнивайте прогноз `rows=` с реальным количеством строк `actual rows=`. Значительные расхождения указывают на проблему.  

```sql
Seq Scan on clients  (cost=0.00..42.16 rows=2016 width=267) 
                     (actual time=0.018..0.197 rows=1008 loops=1) -- актуальное количество ниже ожидаемого, это пробелма
```

Когда статистика обновляется:  
✅ Автоматически: после команд `INSERT`, массовых изменений данных  
❌ Не обновляется автоматически: после `DELETE`, некоторых операций обновления  
⚠️ Вручную: командой `ANALYZE table_name`;  

Практическое правило: При анализе плана запроса всегда проверяйте соответствие прогнозируемого и фактического количества строк на каждом этапе. При обнаружении расхождений > 30% — выполните принудительный сбор статистики. Особое внимание — таблицам после массовых удалений или сложных миграций данных.  

Команда для обновления: `ANALYZE verbose table_name`; — покажет детали сбора статистики.   


