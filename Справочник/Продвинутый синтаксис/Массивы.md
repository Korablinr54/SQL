# Массивы
## Определение
**Массив** — это упорядоченная коллекция элементов одного типа данных.  
<br>
Ключевые особенности массивов в PostgreSQL:  
* **Однотипность элементов** Все элементы массива должны быть одного типа (например, только числа, только строки и т. д.).  
* **Индексируемость** Каждый элемент имеет свой индекс (порядковый номер), начиная с 1 (или с 0, если используется специальная настройка). Доступ к элементам осуществляется по индексу: имя_массива[индекс].  
* **Гибкость хранения данных** Массивы полезны, когда нужно хранить список значений в одной ячейке таблицы.  

Например, в базе данных сервиса такси можно хранить дополнительные номера телефонов клиента в виде массива, в то время как основной номер хранится отдельно.  

| Критерий               | Массив в одной колонке (`add_phones`) | Отдельная таблица (`client_phones`) |
|------------------------|---------------------------------------|-------------------------------------|
| **Дублирование данных** | Нет дублирования данных клиента       | Требует хранения `client_id` для каждой записи |
| **Сложность запросов**  | Простые выборки                      | Требует JOIN для объединения данных |
| **Гибкость**           | Только хранение номеров              | Можно добавить атрибуты (тип, дата и т.д.) |
| **Производительность** | Лучше для небольших наборов данных   | Лучше для больших наборов данных и сложных запросов |
| **Масштабируемость**   | Плохо для >15 элементов              | Хорошо для любого количества записей |
| **Использование**       | Простые случаи (доп. номера без метаданных) | Сложные случаи (нужна доп. информация о номерах) |

| id | client_name          | phone      | add_phones                     |
|----|----------------------|------------|--------------------------------|
| 1  | Иванов Петр Сергеевич | 79991234567 | {79167654321, 79035671234}     |
| 2  | Смирнова Анна Дмитриевна | 79876543210 | {79991112233, 79213457689}     |
| 3  | Козлов Денис Викторович | 79780001122 | {79152223344}                 |  

Без массива пришлось бы создавать отдельную таблицу для номеров, например:  
| client_id | phone_type | phone      |
|-----------|------------|------------|
| 1         | main       | 79991234567|
| 1         | additional | 79167654321|
| 1         | additional | 79035671234|  

<br>

## Одномерный массив
Одномерный массив можно представить как некую последовательность. Каждый элемент в нём определяют с помощью одного индекса.  
| Индекс | 1 | 2 | 3 | 4 | 5 |
|--------|---|---|---|---|---|
| Элемент | C | f | s | p | v |

 id | client_name          | phone      | add_phones               |
|----|----------------------|------------|--------------------------|
| 1  | Иванов П.С.          | 79991234567 | {'79167654321','79035671234'} |
| 2  | Смирнова А.Д.        | 79876543210 | {'79991112233'}          |

**Характеристики**:  
* Размерность: 1  
* Размер: 5 элементов  

<br>

## Двумерный массив
Многомерный массив — это буквально «массив из массивов». Так, двумерный массив — это массив одномерных массивов.  

| Индекс \ Номер массива | 1 (Массив №1) | 2 (Массив №2) | 3 (Массив №3) |
|------------------------|---------------|---------------|---------------|
| **1**                  | с             | w             | e             |
| **2**                  | f             | a             | r             |
| **3**                  | s             | x             | s             |
| **4**                  | p             | t             | f             |  

| id | client_name    | phone      | phones_with_labels                     |
|----|----------------|------------|----------------------------------------|
| 1  | Козлов Д.В.    | 79780001122 | {{'work','79152223344'},{'home','79001112233'}} |
| 2  | Петрова М.К.   | 79654321098 | {{'emergency','79990001122'}}          |  

**Характеристики**:  
* Размерность: 2  
* Размер №1 (строки): 4  

<br>

## Трехмерный массив
| Уровень \ Срез | Срез №1       | Срез №2       | Срез №3       |
|----------------|---------------|---------------|---------------|
| **Слой 1**     | [a, b, c]     | [d, e, f]     | [g, h, i]     |
| **Слой 2**     | [j, k, l]     | [m, n, o]     | [p, q, r]     |  

| id | client_name    | current_phone | phone_history                                                                 |
|----|----------------|---------------|-------------------------------------------------------------------------------|
| 1  | Сидоров В.П.   | 79160000000   | {{{'2020-01','79161111111'},{'2021-05','79162222222'}},{{'2023-01','79160000000'}}} |
| 2  | Николаева Л.Р. | 79250000000   | {{{'2021-02','79251111111'}},{{'2022-03','79252222222'},{'2023-04','79250000000'}}} |

**Характеристики**:  
* Размерность: 3  
* Размер №1 (срезы): 3  
* Размер №2 (слои): 2  
* Размер №3 (элементы): 3  

<br>

## Особенности массивов в PostgreSQL
| Характеристика          | Описание в контексте PostgreSQL                                                                 |
|-------------------------|------------------------------------------------------------------------------------------------|
| **Типы данных**         | Могут быть любые: `INTEGER[]`, `TEXT[]`, `VARCHAR(11)[]`, `BOOLEAN[]` и пользовательские типы |
| **Индексация**          | Начинается с **1** (не с 0). Пример: `array_name[1]` — первый элемент                          |
| **Динамичность**        | Размер/размерность меняется автоматически при добавлении элементов                             |
| **Гибкость размерности**| В одной колонке могут сосуществовать массивы разной размерности (1D, 2D и т.д.)               |

<br>

# Создание массивов
При объявлении (создании) поля с типом данных «массив» используют указание типа данных элементов массива (здесь это text) и квадратные скобки `[]` или слово `ARRAY`.  
```sql
  DROP TABLE IF EXISTS Arrays; 
CREATE TABLE arrays (
       id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
       first_name varchar(128),
       last_name varchar(128),
       primary_phone bigint UNIQUE CHECK (primary_phone > 0),
       secondary_phone bigint[] -- Вместо квадратных скобок можно использовать ключевое слово ARRAY:
);
```

Для создания многомерного массива нужно изменить количество `[]` по количеству измерений. При этом ни использование двух пар квадратных скобок, ни указание размера по каждому измерению не несут никаких дополнительных преимуществ. Вы также сможете вставить в таблицу, созданную последним скриптом, трёхмерный массив с десятью элементами в каждом измерении.  
```sql
DROP TABLE IF EXISTS arrays;
CREATE TABLE arrays (
       id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
       first_name varchar (128),
       last_name varchar (128),
       phone bigint UNIQUE CHECK (phone > 0),
       email varchar (128) UNIQUE,
       antropometry varchar (32) [][] -- двумерный массив
       );
```

<br>

# Вставка элементов массива
Есть два варианта синтаксиса при формировании массива:  
* Фигурные скобки `{}`;  
* Конструктор `ARRAY`.  
```sql
INSERT INTO arrays (first_name, last_name, phone, email, antropometry)
VALUES
('Иван', 'Замочников', 89609471899, 'example@yandex.ru', '{{Рост, 175}, {Вес, 75}, {Цвет волос, Русый.}}'),
('Алексей', 'Кузнецов', 89609731899, 'example@rambler.ru', ARRAY[['Рост', '180'], ['Вес', '90'], ['Цвет волос', 'Черный']])
```  
| id                                   | first_name | last_name  | phone       | email               | antropometry                               |
|--------------------------------------|------------|------------|-------------|---------------------|--------------------------------------------|
| 2a672311-d240-4eb9-90df-1c8fd7977b47 | Иван       | Замочников | 89609471899 | example@yandex.ru   | {{Рост,175},{Вес,75},{"Цвет волос",Русый}} |
| 834fac8c-0e58-4600-8d87-a5e9bfaf567b | Алексей    | Кузнецов   | 89609731899 | example@rambler.ru  | {{Рост,180},{Вес,90},{"Цвет волос",Черный}} |

**Внимание**:  
1. Метод с фигурными скобками `{}`  
PostgreSQL видит это как единую строку, которая будет преобразована в массив только при вставке в таблицу. На этапе парсинга SQL это просто текст, поэтому числа без кавычек не вызывают ошибки.  
2. Метод с конструктором `ARRAY` - немедленная проверка типов  
PostgreSQL немедленно пытается создать массив и проверить типы данных. Здесь 'Рост' - строка, а 180 - число. Это смешение типов вызывает ошибку, так как массив не может содержать элементы разных типов.  

<br>

# Чтение из массива
## Чтение элемента массива по индексу:
```sql
SELECT antropometry[1][2], *
  FROM test.arrays
 WHERE first_name = 'Иван';
```
При использовании трехмерных массиво поиск элемента становится непростой задачей.  

| antropometry | id                                   | first_name | last_name  | phone       | email             | antropometry                               |
|--------------|--------------------------------------|------------|------------|-------------|-------------------|--------------------------------------------|
| 175          | 2a672311-d240-4eb9-90df-1c8fd7977b47 | Иван       | Замочников | 89609471899 | example@yandex.ru | {{Рост,175},{Вес,75},{"Цвет волос",Русый}} |

<br> 

## Чтение через UNNEST
```sql 
SELECT *, UNNEST(antropometry)
  FROM test.arrays
 WHERE first_name = 'Иван'
```
| id                                   | first_name | last_name  | phone       | email             | antropometry                               | unnest     |
|--------------------------------------|------------|------------|-------------|-------------------|--------------------------------------------|------------|
| 2a672311-d240-4eb9-90df-1c8fd7977b47 | Иван       | Замочников | 89609471899 | example@yandex.ru | {{Рост,175},{Вес,75},{"Цвет волос",Русый}} | Рост       |
| 2a672311-d240-4eb9-90df-1c8fd7977b47 | Иван       | Замочников | 89609471899 | example@yandex.ru | {{Рост,175},{Вес,75},{"Цвет волос",Русый}} | 175        |
| 2a672311-d240-4eb9-90df-1c8fd7977b47 | Иван       | Замочников | 89609471899 | example@yandex.ru | {{Рост,175},{Вес,75},{"Цвет волос",Русый}} | Вес        |
| 2a672311-d240-4eb9-90df-1c8fd7977b47 | Иван       | Замочников | 89609471899 | example@yandex.ru | {{Рост,175},{Вес,75},{"Цвет волос",Русый}} | 75         |
| 2a672311-d240-4eb9-90df-1c8fd7977b47 | Иван       | Замочников | 89609471899 | example@yandex.ru | {{Рост,175},{Вес,75},{"Цвет волос",Русый}} | Цвет волос |
| 2a672311-d240-4eb9-90df-1c8fd7977b47 | Иван       | Замочников | 89609471899 | example@yandex.ru | {{Рост,175},{Вес,75},{"Цвет волос",Русый}} | Русый      |

 <br> 

# Функции для работы с массивами
## Обновить данные массива
### Добавить элемент в конец массива

**Конкатенация** `||`  
Создадим таблицу:  
```sql
DROP TABLE IF EXISTS test.clients;
 CREATE TABLE test.clients(
 id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
 name varchar(255),
 email varchar(100) UNIQUE,
 phone bigint UNIQUE,
 add_phone bigint [] 
 );
```  

Вставим строку в таблицу:  
```sql
INSERT INTO test.clients (name, email, phone, add_phone)
VALUES ('Александр Петрович', 'petrovka@mail.ru', 9609461799, ARRAY[9609461798]);
```  

Теперь обновим данные в массиве добавив в конец массива еще один элемент через конкатенацию:  
```sql
UPDATE test.clients 
   SET add_phone = add_phone || ARRAY[9609541788] 
 WHERE 1 = 1 
   AND email = 'petrovka@mail.ru';
```
Данные успешно обновлены!  

Если данные нужно добавить не в конец а в начало массива то просто имзеним запись на: ```ARRAY[9609541788] || add_phone```  

<br>  

### ARRAY_PREPEND
Если нужэно добавить данные в начало массива используем prepend, если в конец то append. Обратите внимание, что аргументы также меняются местами:
```sql
UPDATE test.clients
   SET add_phone = ARRAY_PREPEND('111111111', add_phone)
 WHERE name = 'Александр Петрович'
```  

<br>  

### ARRAY_APPEND  
`ARRAY_APPEND(массив, добавляемый элемент)`  
Добавим еще один номер телефона используя функцию `ARRAY_APEND`.  
```sql
UPDATE test.clients 
   SET add_phone = ARRAY_APPEND(add_phone, '9600000000')
 WHERE 1 = 1 
   AND email = 'petrovka@mail.ru';
```

Проверим вывод:
```sql
SELECT add_phone[:]
  FROM test.clients
 WHERE 1 = 1 
   AND email = 'petrovka@mail.ru';

или

 SELECT id, name, email, phone, UNNEST(add_phone) 
   FROM test.clients
  WHERE 1 = 1 
    AND email = 'petrovka@mail.ru';
```

Результат:   
| id                                   | name               | email             | phone      | unnest     |
|--------------------------------------|--------------------|-------------------|------------|------------|
| 91cc8fe5-3929-4c6f-91d5-dfb6a73270c5 | Александр Петрович | petrovka@mail.ru | 9609461799 | 9609461798 |
| 91cc8fe5-3929-4c6f-91d5-dfb6a73270c5 | Александр Петрович | petrovka@mail.ru | 9609461799 | 9609541788 |
| 91cc8fe5-3929-4c6f-91d5-dfb6a73270c5 | Александр Петрович | petrovka@mail.ru | 9609461799 | 9600000000 |  

 <br>  

### ARRAY_REMOVE
Для удаления элемента массива используем `ARRAY_REMOVE(field, value)`  
```sql
 UPDATE test.clients
    SET add_phone = ARRAY_REMOVE(add_phone, 111111111)
  WHERE 1 = 1
    AND email = 'petrovka@mail.ru';
```

 <br>  


### Заменить элемент массива по индексу

Проапдейтим элемент массива явно указав его индекс в запросе:  
```sql
UPDATE test.clients 
   SET add_phone[3] = 9609461755
 WHERE 1 = 1 
   AND email = 'petrovka@mail.ru';
```
Результат:   
| id                                   | name               | email             | phone      | unnest     |
|--------------------------------------|--------------------|-------------------|------------|------------|
| 91cc8fe5-3929-4c6f-91d5-dfb6a73270c5 | Александр Петрович | petrovka@mail.ru | 9609461799 | 9609461798 |
| 91cc8fe5-3929-4c6f-91d5-dfb6a73270c5 | Александр Петрович | petrovka@mail.ru | 9609461799 | 9609541788 |
| 91cc8fe5-3929-4c6f-91d5-dfb6a73270c5 | Александр Петрович | petrovka@mail.ru | 9609461799 | 9609461755 |  

Можно заменить любое количество элементов используяю слайсинг:  
```sql
UPDATE test.clients 
   SET add_phone[2:] = ARRAY[9609461111, 9609462222]
 WHERE 1 = 1 
   AND email = 'petrovka@mail.ru';
```  
Результат:   
| id                                   | name               | email             | phone      | unnest     |
|--------------------------------------|--------------------|-------------------|------------|------------|
| 91cc8fe5-3929-4c6f-91d5-dfb6a73270c5 | Александр Петрович | petrovka@mail.ru | 9609461799 | 9609461798 |
| 91cc8fe5-3929-4c6f-91d5-dfb6a73270c5 | Александр Петрович | petrovka@mail.ru | 9609461799 | 9609461111 |
| 91cc8fe5-3929-4c6f-91d5-dfb6a73270c5 | Александр Петрович | petrovka@mail.ru | 9609461799 | 9609462222 | 

<br>  

### Поиск по значению в массиве
Например, попробуем отобрать всех людей с ростом выше 175 см:  
```sql 
 SELECT first_name, 
        last_name, 
        antropometry[1][1] AS показатель,
        antropometry[1][2] AS значение
   FROM test.arrays
  WHERE 1 = 1
    AND antropometry[1][2] > '175' 
```
Результат:  
first_name|last_name|показатель|значение|
----------|---------|----------|--------|
Алексей   |Кузнецов |Рост      |180     |  

<br>

Другой пример, индекс искомого элемента не известен. Нужно найти клиента по дополнительному номеру. Нам поможет `ANY`:  
```sql
 SELECT *
   FROM test.clients
  WHERE 9609461798 = ANY(add_phone);
```
Результат:  
id|name|email|phone|add_phone|
-|-|-|-|-|
91cc8fe5-3929-4c6f-91d5-dfb6a73270c5|Александр Петрович|petrovka@mail.ru|9609461799|{9609461798,9609461111,9609462222}|  

<br>

Либо, можно использовать смледующий синтаксис. Результат будет аналогичным:  
```sql
 SELECT *
   FROM test.clients
  WHERE add_phone && ARRAY[9609461798];
```
Проверить пересечение массивов можно с помощью оператора `&&.` Он принимает два массива (слева и справа от себя) и возвращает `true`, если у них есть общие элементы, или `false`, если таких элементов нет.  

<br>

Если мы првоеряем не конкретный элемент а все, например, найдем клиентов выше 175:  
```sql
 SELECT first_name, 
        last_name, 
        UNNEST(antropometry)
   FROM test.arrays
  WHERE '175' < ALL(antropometry);
```  
Условие `WHERE` означает «175 меньше всех элементов массива antropometry.  
* Пример не совсем корректен т.к. массив содержит данные в виде строки, но принцип в целмо понятен.  

## Операторы для работы с массивами

### Сравнение массивов  
Два массива равны, когда у них одинаковая размерность и равны все их элементы.   
   
<br>  

**Массивы равны** - одинаковые размерность элементы и их порядок.  

```SQL
SELECT ARRAY[1, 2, 3] = ARRAY[1, 2, 3] AS arrays -- true
```  
<br>  

**Массивы не равны** - разная размерность массива.
  
```SQL
SELECT ARRAY[1, 2, 3] = ARRAY[[1, 2, 3]] AS arrays -- false
```  
  
<br>  

**Массивы не равны** - хоть элементы и размерность совпадают а вот порядок элементов отличается.
  
```SQL
SELECT ARRAY[1, 2, 3] = ARRAY[3, 2, 1] AS arrays -- false
```   

<br>  

Вариант с `<>` работает похожим образом но наоборот:  
```SQL
SELECT ARRAY[1, 2, 3] <> ARRAY[1, 2, 3]; -- false
SELECT ARRAY[1, 2, 3] <> ARRAY[[1, 2, 3]]; -- true
SELECT ARRAY[1, 2, 3] <> ARRAY[3, 2, 1]; -- true
```

### Определения вхождения 
Один массив входит в другой если все элементы одного массива встречаются в другом.  
`@>` и его зеркальная форма `<@`  

`arr1 @> arr2` - проверяет, что массив **arr1** содержит в себе массив **arr2**.   
```SQL
SELECT ARRAY[1, 2, 3, 4, 5] @> ARRAY[3, 2, 1] AS Arrays -- true
```

<br>  

`arr2 <@ arr1` - **arr2** содержится в **arr1**.  
```SQL
SELECT ARRAY[1, 2, 3] <@ ARRAY[3, 2, 1, 4, 5] AS arrays -- true
```

## Функции для работы с массивами
### ARRAY_LENGTH
Функция для определения длинны массива. Принимает два аргумента: сам массив и его размерность.

<br>  

**Одномерный массив**:
```SQL
SELECT ARRAY_LENGTH(ARRAY[1, 2, 3], 1) AS array -- 3
```
<br>  

**Двумерный массив**:
```SQL
SELECT ARRAY_LENGTH(ARRAY[[1, 2, 3, 4, 5], [1, 2, 3, 4, 5]], 2) AS array -- 5
```
<br>  

**Двумерный массив** - определить длинну самого первого массива:
```SQL
SELECT ARRAY_LENGTH(ARRAY[[1, 2, 3], 
                          [1, 2, 3], 
                          [1, 2, 3]], 1) AS array -- 3
```  

### ARRAY_TO_STRING
Функция позволяет развернуть массив в строку. Принимает два обязательных аргумента и один не обязательный:  
1) сам массив;  
2) разделитель;  
3) значение, которое будет подставлено на место Null.  
```SQL
SELECT ARRAY_TO_STRING(ARRAY['Red', 'Blue', Null, 'Green'], ' / ', 'XXX')   
-- Red / Blue / XXX / Green
```

Работает и с многомерными массивами:  
```SQL
SELECT ARRAY_TO_STRING(ARRAY[['Red', 'Blue', NULL, 'Green'],
                             ['Car', 'Sky', NULL, 'Grass']],  ' / ', 'XXX') 
 -- Red / Blue / XXX / Green / Car / Sky / XXX / Grass                            
```  

### STRING_TO_ARRAY
Функция, принимающая на вход строку и разделитель, позволяет переформатировать строку в массив. Третий аргумент заменит строку на Null:  
```SQL
SELECT STRING_TO_ARRAY('Red, Blue, Green, Car, Sky, Grass', ', ', 'Red')
/*
[Null,
Blue,
Green,
Car,
Sky,
Grass]
*/
```

### UNNEST
Функция "разбирает" массив и выводит результат в одельной строке для каждого элемента массива:  
```SQL
 SELECT id, name, email, phone, UNNEST(add_phone) 
   FROM test.clients
  WHERE 1 = 1 
    AND email = 'petrovka@mail.ru'
```  
| id                                  | name              | email           | phone     | unnest    |
|-------------------------------------|-------------------|-----------------|-----------|-----------|
| 0b1ceb9f-9ff4-47ce-9f28-8c30396b3487 | Александр Петрович | petrovka@mail.ru | 9609461799 | 9609461798 |
| 0b1ceb9f-9ff4-47ce-9f28-8c30396b3487 | Александр Петрович | petrovka@mail.ru | 9609461799 | 9609461111 |  

